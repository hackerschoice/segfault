#! /bin/bash -r

# This is called by SSHD inside SF-HOST docker.
# - All environments have been cleared by SSHD.
# - Redirects not allowed in restricted shells.
# - bash's 'source' is prohibited (use 'eval' instead)
# - This script might be executed inside the LG's network namespace
#   (if 'ssh -M -S ~/.ssh/foobar' and 'ssh -S ~/.ssh/foobar' is used for multiplexing/Mastering)
#
# This script can be run from the source directory for testing.
# SF_BASEDIR must point to the source directory.
#    su - sf-user
#    export SF_BASEDIR=/home/sf-user/x/segfault-0.2.2a
#    cd /segfault/host/fs-root/bin
#    SF_DEBUG=1 SF_EMU=1 SF_SEED=foobar3 ./segfaultsh

# Load/restore environment variables from file
# SF_DEBUG can be set by ssh-client with -o SetEnv SF_DEBUG=1 or by
# docker compose '.env' file.
[[ -t 1 ]] && {
CY="\e[1;33m" # yellow
CDY="\e[0;33m" # yellow
CR="\e[1;31m" # red
CB="\e[1;34m" # blue
CC="\e[1;36m" # cyan
CG="\e[1;32m" # green
CDG="\e[0;32m" # green
CDC="\e[0;36m" # cyan
CDR="\e[0;31m" # red
CDB="\e[0;34m" # blue
CDM="\e[0;35m" # magenta
CN="\e[0m"    # none
CW="\e[1;37m" # white
CF="\e[2m"    # faint
CUL="\e[4m"
CRY="\e[0;33;41m"  # YELLOW on RED (warning)
}
XCY="\e[1;33m" # yellow
XCDY="\e[0;33m" # yellow
XCR="\e[1;31m" # red
XCB="\e[1;34m" # blue
XCC="\e[1;36m" # cyan
XCG="\e[1;32m" # green
XCDG="\e[0;32m" # green
XCDC="\e[0;36m" # cyan
XCDR="\e[0;31m" # red
XCDB="\e[0;34m" # blue
XCDM="\e[0;35m" # magenta
XCN="\e[0m"    # none
XCW="\e[1;37m" # white
XCF="\e[2m"    # faint
XCUL="\e[4m"
XCRY="\e[0;33;41m"  # YELLOW on RED (warning)


SSH_SF_DEBUG="${SF_DEBUG}" # Set by SSH client
eval "$(cat /dev/shm/env.txt || echo false)" || exit
[[ -z $SF_DEBUG ]] && SF_DEBUG="${SSH_SF_DEBUG}"
unset SSH_SF_DEBUG
# Needed when executing segfaultsh-debug (because PPID then no longer points to sshd)
export SSHD_PID="${SSHD_PID:-$PPID}"
# Start experimental segfaultsh for testing...
[ -z "$SF_DEBUG_SH" ] && [ -n "$SF_DEBUG" ] && [ -f "/bin/segfaultsh-debug" ] && { SF_DEBUG_SH=1 bash -c 'exec /bin/segfaultsh-debug "$@"' -- "$@"; exit; }
eval "$(cat /sf/bin/funcs_redis.sh || echo false)" || exit
# Debug Trace. see sf_trace-DISABLED
[[ -f /bin/sf_trace ]] && eval "$(</bin/sf_trace)"


# [PREFIX] [MSG]
_log()
{
	local str
	local p
	p="$1"
	shift 1

	[[ -z $IS_LOGGING ]] && return

	# Replace ' with '"'"'
	str="${*//\'/\'\"\'\"\'}"
	# NOTE: segfault.log must be owned 1000:1000
	bash -c "{ echo -en '[$(date '+%F %T' -u)]${p:- }[${XCDM}${LID}${XCN}] '; echo -e '$str';} 2>/dev/null >>'${SF_RUN_DIR}/logs/segfault.log'"
}

LOG(){ _log "" "$@"; }
LOG_E() { _log " ${XCR}ERROR${XCN} " "$@";}
LOG_W() { _log " ${XCDY}WARN${XCN} " "$@";}

do_exit() {
	sem_release
	logout
	exit "${1:-0}"
}

ERREXIT() {
	local code="$1"

	LOG_E "$@"
	shift 1
	[[ -n $1 ]] && echo -e >&2 "💥 ${CR}ERROR:${CN} $*${CN}"

	# Clean up if server was just created.
	# Note: This function might be called before SF_USER_DB_DIR is set.
	[ -n "$SF_USER_DB_DIR" ] && [ -n "$SF_IS_NEW_SERVER" ] && {
		[ -d "${SF_USER_DB_DIR:?}" ] && rm -rf "${SF_USER_DB_DIR}"
	}

	do_exit "${code:-99}"
}

STOPEXIT() {
	local l
	l="$1"

	shift 1
	exec_devnull docker stop "lg-${l}"
	ERREXIT "$@"
}

# NOTE: This function might get called from ERREXIT and before all variables are set.
logout()
{
	local fn
	local pid
	local is_last
	# bash signal race condition: Might be called twice if signal arrives while
	# in this function.
	trap '' SIGHUP
	trap '' SIGTERM
	trap '' SIGPIPE
	[[ -f "${LG_PID_FILE}" ]] && rm -f "${LG_PID_FILE:?}"
	[[ -d "${SF_USER_DB_DIR}" ]] && touch "${TS_LOGOUT_FILE:?}"

	[[ -n $LG_PID_DIR ]] && [[ -n $LID ]] && {
		# Delete IS_LOGGED_IN_FILE if this is the last session to exit.
		is_last=1
		for fn in "${LG_PID_DIR}/pid-${LID}."*; do
			[[ ! -f "$fn" ]] && break # No pid file exists for this LID
			pid=${fn##*.}
			[[ ! -d "/proc/${pid}" ]] && {
				# Happens when 'Failed to set up guest instance' is triggered.
				LOG_E "Stale: pid-${LID}.${pid} [removed]"
				rm -f "${fn}" 
				continue
			}
			unset is_last
		done
	}

	[[ -n $is_last ]] && {
		# LOG "Last PID"
		[[ -f "${IS_LOGGED_IN_FILE:?}" ]] && rm -f "${IS_LOGGED_IN_FILE}"
	}
}

sem_wait()
{
	IS_SEM_WAIT=1
	redq BLPOP "${LG_SEM:?}" 5 || ERREXIT 238 "Could not get lock: ${LG_SEM}"
	redq BLPOP "sema:destructor" 5 || ERREXIT 238 "Could not get lock: destructor"
}

sem_release()
{
	[[ -z $IS_SEM_WAIT ]] && return
	# unset _before_ potential call to ERREXIT().
	unset IS_SEM_WAIT
	echo "DEL '${LG_SEM}'"$'\n'"RPUSH '${LG_SEM}' 1" | red1 || ERREXIT 237 "Could not release lock: ${LG_SEM}"
	echo "DEL 'sema:destructor'"$'\n'"RPUSH 'sema:destructor' 1" | red1 || LOG_E "Could not release lock: sema:destructor"
}

if [[ -z $SF_DEBUG ]]; then
	DEBUGF(){ :;}
	SF_DOCKER_LOG="none"
else
	DEBUGF(){ echo -e 1>&2 "${CY}DEBUG:${CN} $*";}
	SF_DOCKER_LOG="local"
fi

argv2esc()
{
	local s
	local x
	local str

	for x in "$@"; do
		# Esacpe ' with '"'"'
		str="${x//\'/\'\"\'\"\'}"
		s+=" '$str'"
	done

	echo "$s"
}

# The current 'restricted shell' does not allow for stdout redirection to /dev/null.
# Thus execute in unrestricted shell with 'exec_devnull' and redirect stdout to /dev/null. 
exec_devnull()
{
	local argstr
	local bin

	bin="$1"
	shift 1

	argstr="$(argv2esc "$@")"
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec \"$bin\" $argstr 2>/dev/null >/dev/null"
	else
		# DEBUGF "EXEC \"$bin\" $argstr"
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		bash -c "exec \"$bin\" $argstr"
	fi
}

exec_errnull()
{
	local argstr
	local bin

	bin="$1"
	shift 1

	argstr="$(argv2esc "$@")"
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec \"$bin\" $argstr 2>/dev/null"
	else
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		bash -c "exec \"$bin\" $argstr"
	fi
}

logpipe() {
	[[ ! -e "${SF_RUN_DIR}/logpipe/logPipe.sock" ]] && return

	echo "$*" | exec_devnull unix-socket-client 
}

# Overcoming a restricted shell. Write $1 to file in $2
# tofile "foobar \$HOME \"|';id;" world.txt
tofile()
{
	local str
	# Replace ' with '"'"'
	str="${1//\'/\'\"\'\"\'}"
	bash -c "echo '$str' 2>/dev/null >'$2'"
}

# Set $1 to $2 if $1 is not already set.
emu_set_env()
{
	eval "[[ -n \"\$$1\" ]]" && return
	echo "[+] EMULATION: Setting $1=$2"
	eval "$1"=\""${2}"\"
}

init_emu_tor()
{
	local fn
	fn="${SF_CFG_GUEST_DIR}/onion_hostname-$1"

	[[ -e "$fn" ]] && return

	local str
	str="${1}-EMULATIONxxxxxalsdjfkljasdflkasdlkfjaldsfadlsgiahfgljzhfkawhrkt"
	tofile "${str:0:56}.onion" "${fn}"
}


xmkdir()
{
	[[ -d "$1" ]] && return
	mkdir -p "$1"
}

# segfaultsh started directly from the command shell (for testing & development)
# SF_BASEDIR=/home/sf-user/segfault-src
# SF_EMU_PREFIX="${SF_BASEDIR}/emu"
# mkdir "$SF_EMU_PREFIX"
# SF_DEBUG=1 SF_SEED=foobar3 ./segfaultsh
init_emu()
{
	[[ -z $SF_EMU ]] && return

	SF_EMU_DIR="${SF_BASEDIR}/emu"
	SF_SEC_DIR="${SF_BASEDIR}/emu/sec/www-root"
	SF_CONFIG_DIR="${SF_BASEDIR}/emu/config"
	SF_ETCSF_DIR="${SF_BASEDIR}/config/etc/sf"
	SF_HOST_FS_ROOT="${SF_BASEDIR}/host/fs-root"

	[[ ! -d $SF_EMU_DIR ]] && mkdir "${SF_EMU_DIR}"

	[[ ! -d "${SF_SEC_DIR}" ]] && mkdir -p "${SF_SEC_DIR}"
	[[ ! -f "${SF_SEC_DIR}/.IS-ENCRYPTED" ]] && touch "${SF_SEC_DIR}/.IS-ENCRYPTED"

	emu_set_env SF_DNS "1.1.1.1"
	emu_set_env SF_FQDN "EMULATION.segfault.net"
	emu_set_env SF_TOR_IP "10.0.0.111"
	emu_set_env SF_USER "root"
	emu_set_env SSH_CONNECTION "1.2.3.4 31337 10.0.2.15 22"
	export SSH_CONNECTION

	# Overwrite defaults to run in EMULATOR
	SF_CFG_GUEST_DIR="${SF_EMU_DIR}/config-for-guest"
	SF_GUEST_SELFDIR="${SF_EMU_DIR}/self-for-guest"
	SF_ENCFS_SEC_DIR="${SF_EMU_DIR}/encfs-sec"

	xmkdir "${SF_ENCFS_SEC_DIR}"
	xmkdir "${SF_CFG_GUEST_DIR}"
	xmkdir "${SF_ENCFS_SEC_DIR}/lg-${LID}"
	xmkdir "${SF_ENCFS_SEC_DIR}/everyone-root"
	xmkdir "${SF_ENCFS_SEC_DIR}/everyone-root/everyone"
	xmkdir "${SF_ENCFS_SEC_DIR}/www-root/www/${SF_HOSTNAME,,}"

	[[ ! -f "${SF_CFG_GUEST_DIR}/id_ed25519" ]] && ssh-keygen -q -t ed25519 -C "" -N "" -f "${SF_CFG_GUEST_DIR}/id_ed25519"
	[[ -f "${SF_CFG_GUEST_DIR}/id_ed25519.pub" ]] && rm -f "${SF_CFG_GUEST_DIR}/id_ed25519.pub"

	init_emu_tor 22
	init_emu_tor 80

	exec_devnull docker network create -d bridge sf-guest
}

init_defaults()
{
	[[ -z $SF_BASEDIR ]] && ERREXIT 1 "SF_BASEDIR= not set"
	SF_SEC_DIR="/sec/www-root"
	SF_CONFIG_DIR="/config/host"
	SF_ETCSF_DIR="/config/host/etc/sf"
	SF_ETCMSG_DIR="/config/host/etc/msg"
	SF_CFG_GUEST_DIR="${SF_SHMDIR}/config-for-guest" # Mounted to /config/guest
	SF_GUEST_SELFDIR="${SF_SHMDIR}/self-for-guest"    # Mounted to /config/self
	SF_ENCFS_SEC_DIR="${SF_SHMDIR}/encfs-sec"
}

# shellcheck disable=SC2317 # Not reachable
cb_sighup()
{
	sem_release
	logout
	exit 200
}

# shellcheck disable=SC2317 # Not reachable
cb_sigterm()
{
	sem_release
	logout
	exit 201
}

init_vars()
{
	local db_dir
	init_defaults
	init_emu

	[[ -z $SF_FQDN ]] && SF_FQDN="this"
	db_dir="${SF_CONFIG_DIR}/db"
	SF_USER_DB_DIR="${db_dir}/user/lg-${LID}"
	SF_BLACKLIST_DIR="${db_dir}/banned"
	SF_TOKEN_DIR="${db_dir}/token"
	SF_LIMITS_DIR="${db_dir}/limits"
	HNLID_DIR="${db_dir}/hn"

	SF_RUN_DIR="/sf/run"
	LG_PID_DIR="${SF_RUN_DIR}/pids"
	LG_PID_FILE="${LG_PID_DIR}/pid-${LID}.$$"
	LG_RUN_DIR="${SF_RUN_DIR}/users/lg-${LID}"
	TS_LOGOUT_FILE="${SF_USER_DB_DIR}/ts_logout"
	TS_LOGIN_FILE="${SF_USER_DB_DIR}/ts_login"
	TS_RUN_FILE="${SF_USER_DB_DIR}/ts_run"
	IS_LOGGED_IN_FILE="${SF_USER_DB_DIR}/is_logged_in"

	NOW="$(date +%s)"
	[[ -z $YOUR_IP ]] && {
		YOUR_IP="${SSH_CONNECTION%%[[:space:]]*}"
		YOUR_IP="${YOUR_IP//[^0-9.:]/}"
		[[ -z $YOUR_IP ]] && ERREXIT 255 "SSH_CONNECTION= is is not set. segfaultsh not started via sshd?"
		# Check if connecting FROM LG: STOP HERE: How can i translate internal IP to lg to then get the international IP?
		[ "${YOUR_IP:0:6}" = "${SF_NET_LG_ROUTER_IP:0:6}" ] && {
			# Your-IP looks very similar to SF_NET_LG. let's confirm with a redis request:
			local arr
			IFS=" " read -r -a arr < <(redr GET "ip:${YOUR_IP}")
			local fn="${SF_RUN_DIR}/ips/lg-${arr[0]}.ip"
			[ -s "${fn}" ] && str="$(<"${fn}")"
			[ -n "$str" ] && YOUR_IP="${str}"
		}
	}
	YOUR_IP_DISPLAY="$YOUR_IP"
	[ -n "$SF_HIDEIP" ] && YOUR_IP_DISPLAY="${YOUR_IP%%.*}.0.0.333"

	# Do not store IP addresses. Hash it with a secret (SEED) instead.
	local str
	str="$(echo -n "IP-${YOUR_IP}-${SF_SEED}" | sha512sum)"
	YOUR_IP_HASH="${str:0:16}"
	[[ -z $YOUR_IP_HASH ]] && ERREXIT 2 "YOUR_IP_HASH= not set"

	# Set the number of CPU's a guest can use up to a max of 4.
	# Min is 1 or NPROC / 4 to a max of 4.
	if [[ -n $SF_CPUS ]]; then
		[[ $SF_CPUS -gt $NPROC ]] && SF_CPUS="$NPROC"
	else
		SF_CPUS=$((NPROC / 4))
		if [[ $SF_CPUS -le 1 ]]; then
			SF_CPUS=1
			[[ $NPROC -ge 2 ]] && SF_CPUS=2
		elif [[ $SF_CPUS -gt 4 ]]; then
			SF_CPUS=4
		fi
	fi

	[[ -f "${SF_RUN_DIR}/logs/segfault.log" ]] && IS_LOGGING=1

	xmkdir "${LG_RUN_DIR}"
	# Check if we are still in sshd's Network Namespace
	IS_SSHD_NS_NET=1
	[[ ${SF_NS_NET:?} != "$(readlink /proc/self/ns/net)" ]] && unset IS_SSHD_NS_NET # Already inside LG's Network Namespace

	trap cb_sighup SIGHUP
	trap cb_sigterm SIGTERM
	trap cb_sighup SIGPIPE
}

# Called when a new server is created.
print_disclaimer()
{
	echo 1>&2 -e "\
${CR}######################################################################
#### ${CY}DISCLAIMER: TO BE USED FOR CREATIVE AND GOOD PURPOSES ONLY.. ${CR}####
#### ${CY}TO TINKER AND TO EXPLORE.     >>>USE AT YOUR OWN RISK<<<     ${CR}####
######################################################################${CN}"
}

# Return TRUE if 'y' is pressed.
prompt_wait_yN()
{
	local p
	local sec
	local IFS
	sec=$1
	p="$2"

	echo -en "$p (y/N) "
	IFS=$'\n'
	read -r -n1 -t"${sec}" yn || { echo -e "${CF}N${CN}"; return 255; } # Timeout. Print "N\n"
	[[ -z $yn ]] && return 255                       # Enter pressed. \n already displayed (echo'ed)
	echo "" # Print \n
	[[ "${yn^^}" != "Y" ]] && return 255

	return 0
}

# Output GOODBYE message with infos how to connect back to this shell
print_goodbye()
{
	local str
	local IFS
	[[ -z $IS_LOGIN ]] && return
	[[ -n $SF_HUSHLOGIN ]] && return

	# Restricted shell (-r) wont let us redirect stderr - use a bash-exec trick
	# Note: pgrep is executed in user's context. Treat the output with care and do not trust it.
	n=$(timeout 2 bash -c "exec docker exec --user 0:0 \"lg-${LID}\" pgrep -c . 2>/dev/null" | head -n1)
	[[ -z "$n" ]] && n=0
	[[ ${#n} -gt 5 ]] && n=0
	[[ ! $n -eq $n ]] && n=0
	n=$((n-2))

	if [[ "$n" -gt 0 ]]; then
		# Display the running processes
		str="process is"
		[[ "$n" -gt 1 ]] && str="processes are"
		echo -e "${CY}WARNING: ${CR}${n}${CY} ${str} still running:${CN}"
		exec_errnull timeout 2 docker exec --user 0:0 "lg-${LID}" pgrep . -al | tail -n+3 | while read -r x; do p="${x%% *}        "; n="${x#* }"; echo -e "${CDY}--> ${CDR}${p:0:8}${CDG}${n:0:68}${CN}"; done
		echo -e "\
-------> The encrypted filesystem in /sec will remain accessible until
-------> the last shell exits or all background processes terminate.
-------> Log back in and type ${CC}halt${CN} instead to stop this server.
-------> This will also make /sec unavailable until your next log in."
	fi
	echo -n $'\r'
	sysmsg "/config/host/etc/logoutmsg-all.sh"

	echo -e "\
📖 RTFM           : ${CB}${CUL}https://www.thc.org/segfault/faq${CN}
🤗 GOODBYE        : ${CW}Join us - https://thc.org/ops${CN}"
	[[ -z $SF_IS_NEW_SERVER ]] && return

	prompt_wait_yN 10 "Would you like to see your ${CDY}SECRET${CN} to log back in to ${CDY}${SF_HOSTNAME:-UNKNOWN}${CN}?" || return

	echo -e "\
SECRET           : ${CDY}${SF_SEC}${CN}
Access with      : ${CDC}ssh secret@${SF_FQDN:-UNKNOWN}${CN}
Access with      : ${CDC}ssh -o \"SetEnv SECRET=${SF_SEC:-UNKNOWN}\" ${SF_USER}@${SF_FQDN:-UNKNOWN}${CN}"
}

print_to_many_servers()
{
	echo >&2 -e "\
[${CR}ERROR${CN}]
--> ${CDY}You ($YOUR_IP) already have ${SF_LIMIT_SERVER_BY_IP} servers running.${CN}
--> Log in to your already running servers before creating any more new servers.
--> Read ${CB}${CUL}https://www.thc.org/segfault/faq/#reconnect${CN}
--> Read ${CB}${CUL}https://www.thc.org/segfault/free${CN}
--> Contact us: ${CW}https://thc.org/ops${CN}"
}

show_last_server()
{
	local n=$1
	echo >&2 -e "\
[${CDY}WARNING${CN}]
--> You (${CDY}$YOUR_IP${CN}) now have $n servers running.
--> ${CRY}You can not create any more servers after this one!${CN}
--> Use your ${CDY}SECRET${CN} to log in to your previously
--> created servers. If you forgot the ${CDY}SECRET${CN} then you need to wait for
--> the servers to time out and shut down automatically. Best to write down
--> the ${CDY}SECRET${CN} for THIS SERVER and follow these instructions:
--> ${CB}${CUL}https://www.thc.org/segfault/faq/#reconnect${CN}"

	prompt_wait_yN 30 "Would you like to see your ${CDY}SECRET${CN} now?" && {
		echo >&2 -e "\
--> SECRET: ${CDY}${SF_SEC:-BAD}${CN}
--> Contact us: ${CW}https://thc.org/ops${CN}"
	}
}

echo_pty() { :;}

sshd_to_ns()
{
	local str

	[[ -z $IS_SSHD_NS_NET ]] && return  # Already in LG's network namespace?

	# Load PID of container's init process (uid=1000)
	[[ -z $LG_PID ]] && {
		# Source:
		eval "$(<"${LG_RUN_DIR}/config.txt")"
		[[ -z $LG_PID ]] && ERREXIT 222 "Init PID not found."
	}
	ln -sf "/proc/${LG_PID}/ns/net" "/dev/shm/ns-net-${SSHD_PID}"
	DEBUGF "Moving SSHD(=$SSHD_PID) to net-NS(=$LG_PID)"
	kill -USR1 "${SSHD_PID:?}" || ERREXIT 221 "Oops. Could not signal SSHD ($SSHD_PID)."
}

spawn_shell_exit()
{
	# $@ is either ("-c", "<command>") or empty
	DEBUGF "ARG(${#})=$*"

	# Move SSHD to guest's network namespace (for -L/-R to work)
	sshd_to_ns

	sem_release

	# Add a log entry into elastisearch using logpipe
	logpipe "Type:Login|LID:${LID}|Hostname:${SF_HOSTNAME}|IPHASH:${YOUR_IP_HASH}|C_ISO:${YOUR_COUNTRY_ISO^^}|CONTINENT=${YOUR_CONTINENT_CODE}|"

	# Update current IP:
	tofile "${YOUR_IP_DISPLAY:?}" "/config/self-for-guest/lg-${LID}/ip"
	tofile "${YOUR_IP:?}" "${SF_RUN_DIR}/ips/lg-${LID}.ip"
	[[ -n $YOUR_GEOIP ]] && tofile "${YOUR_GEOIP}" "/config/self-for-guest/lg-${LID}/geoip"
	# Request a reverse Port Forward
	[[ -n $SF_RPORT_ON_LOGIN ]] && [[ -n $SF_RPORT ]] && [[ ! -f "/config/self-for-guest/lg-${LID}/reverse_ip" ]] && exec_devnull timeout 2 docker exec --user 0:0 "lg-${LID}" curl -s sf/port


	# Warn user if this is the last server by IP (after semaphore has been released)
	[[ -n $IS_SHOW_LAST_SERVER ]] && show_last_server "$IS_SHOW_LAST_SERVER"

	# export SF_LOG="/config/host/log/sigproxy-${LID}-${SF_HOSTNAME}.log"
	docker-exec-sigproxy exec --detach-keys='ctrl-^,z' --workdir=/sec/root --env SF_IS_LOGINSHELL=1 --user 0:0 "${DOCKER_EXEC_ARGS[@]}" "lg-${LID}" nice -n"${SF_USER_NICE_SCORE:?}" zsh "${PARAM[@]}"
	ret="$?" # save return value and exit this script later with same return value.
	DEBUGF "Exited with $ret"
	logout
	print_goodbye

	exit "$ret"
}

# Generate a mnemonic hostname from LID (e.g. ButterflyCat)
mk_hostname()
{
	local num english
	num=$(echo "$LID" | md5sum)
	num=${num%% *}
	num=$((16#${num:0:15}))
	# Oops. bash max integer is (2^63)-1, so limit to 15 hex.
	# num=$(echo "ibase=16; $(echo "$LID" | md5sum | cut -f1 -d" " | tr 'a-z' A-Z)" | bc)
	readarray -t english <"${SF_HOST_FS_ROOT}/etc/english.txt"
	SF_HOSTNAME="UnknownUnknown"
	[[ "${#english[@]}" -lt 2048 ]] && ERREXIT 2 "english.txt bad"
	m=$((num % 2048))
	n=$(( (num / 2048) % 2048))
	SF_NUM="$((m * 2048 + n))"

	SF_HOSTNAME="${english[$m]}"
	SF_HOSTNAME+="${english[$n]}"
	SF_FQ_HOSTNAME="${SF_FQDN%%\.*}-${SF_HOSTNAME}"
}

# 1. Set INODE limit per container. Docker does not support this via any
# --storage-opt. Instead we start the container and add ourself to the
# xfs quota group that docker set up. Yeahaaa..
# 2. Move encfsd into lg's cgroup.
setup_encfsd()
{
	local dir
	local ilimit

	ilimit="$SF_USER_ROOT_FS_INODE"
	[[ -z "${SF_USER_ROOT_FS_SIZE_NUM}" ]] && ilimit=0

	dir=$(docker inspect "lg-${LID}" --format '{{.GraphDriver.Data.UpperDir }}') || return 255
	dir=${dir#*overlay2/}

	res=$(echo -e "RPUSH encfs \"$$ ${LID} X ${CID} ${ilimit:-0} ${dir}\"\n\
BLPOP \"encfs-$$-${LID}-X\" 10" | red) || return 255

	return 0
}

load_limits_fn() {
	local fn=$1
	[[ ! -f "$fn" ]] && return

	eval "$(<"${fn}")"
}

load_limits()
{
	local prefix
	local is_need_update_token
	local str
	local name
	local dst
	local ar arr
	local IFS
	# Set the default values.
	# No default for ROOT_FS limit. Should be set in sf.conf or if not set
	# then root is mounted read-only
	# SF_USER_ROOT_FS_SIZE=8g
	# SF_USER_FS_SIZE=16g
	# SF_USER_ROOT_FS_INODE=65536
	# SF_USER_FS_INODE=65536
	SF_USER_MEMORY_LIMIT=256m
	SF_USER_PIDS_LIMIT=128
	SF_USER_CPU_SHARE=8
	SF_USER_OOM_SCORE=500
	SF_USER_NICE_SCORE=10
	SF_LIMIT_SERVER_BY_IP=8
	SF_USER_BLKIO_WEIGHT=100
	SF_ULIMIT_NOFILE="8192"
	SF_USER_SYN_BURST=8196
	SF_USER_SYN_LIMIT=1
	SF_RPORT=1

	# No new shells until load goes below STRAIN*NPROC.
	# Should be larger than ContainerGuard's strain when CG starts killing
	SF_MAX_STRAIN=100

	# Test blkio_weight:
	# dd bs=1M count=10024 if=/dev/zero of=/dump.dat oflag=direct status=progress

	# Source system wide limits
	load_limits_fn "${SF_ETCSF_DIR}/sf.conf"

	# Source continent specific limits
	load_limits_fn "${SF_LIMITS_DIR}/limits-continent-${YOUR_CONTINENT_CODE}.conf"

	# Source country specific limits
	load_limits_fn "${SF_LIMITS_DIR}/limits-country-${YOUR_COUNTRY_ISO,,}.conf"

	unset prefix
	[[ -n $SF_TOKEN_PREFIX ]] && prefix="${SF_TOKEN_PREFIX//[^a-z]}-"
	if [[ -z $SF_TOKEN ]]; then
		# HERE: SF_TOKEN _not_ supplied
		[[ -f "${SF_USER_DB_DIR}/token" ]] && {
			SF_TOKEN="$(<"${SF_USER_DB_DIR}/token")"
		}
	else
		# HERE: SF_TOKEN is user supplied.
		[[ ! -f "${SF_TOKEN_DIR}/token-${prefix}${SF_TOKEN,,}.conf" ]] && ERREXIT 255 "The TOKEN '${CDY}${SF_TOKEN}${CN}' is not valid."
		logpipe "Type:Token|TOKEN:${SF_TOKEN_NAME}|LID:${LID}|HOSTNAME:${SF_HOSTNAME}|IPHASH:${YOUR_IP_HASH}|C_ISO:${YOUR_COUNTRY_ISO^^}|CONTINENT=${YOUR_CONTINENT_CODE}|"

		is_need_update_token=1
	fi

	[[ -n $SF_TOKEN ]] && {
		# HERE: Got a TOKEN (user supplied or loaded from {lgdir}/token)
		if [[ -f "${SF_TOKEN_DIR}/token-${prefix}${SF_TOKEN,,}.conf" ]]; then
			eval "$(<"${SF_TOKEN_DIR}/token-${prefix}${SF_TOKEN,,}.conf")"
			unset SF_NEED_TOKEN
		else
			# token-<TOKEN>.conf does not exist.
			unset SF_TOKEN
		fi
	}

	[[ -n $SF_TOKEN ]] && [[ -n $SF_TOKEN_IMMUTABLE ]] && [[ -n $is_need_update_token ]] && {
		# Update TOKEN
		tofile "${SF_TOKEN}" "${SF_USER_DB_DIR}/token"
	}

	# Then source user specific limits
	load_limits_fn "${SF_USER_DB_DIR}/limits.conf"

	# Then source IP specific limits
	load_limits_fn "${SF_ETCSF_DIR}/sf-${YOUR_IP}.conf"

	# Check if TOKEN is needed.
	[[ -n $SF_NEED_TOKEN ]] && {
		fn="${SF_ETCMSG_DIR}/token-needed-${SF_NEED_TOKEN//[^a-z._]}"
		# Display a message if TOKEN is needed
		echo -e "💥 ${CR}ERROR${CN}: A TOKEN is needed to use the system. Please contact a SysCop to get one."
		[[ -e "${fn} " ]] && eval "$(<"$fn")"

		exit 255
	}

	# Add SF docker args to LG container.
	[[ ${#SF_USER_DOCKER_ARGS[@]} -gt 0 ]] && DOCKER_ARGS+=("${SF_USER_DOCKER_ARGS[@]}")

	# User gets a reverse port on login
	[[ -n $SF_RPORT_ON_LOGIN ]] && SF_RPORT=1

	# Set swap limit if not set in sf.conf
	[[ -z $SF_USER_MEMORY_AND_SWAP_LIMIT ]] && SF_USER_MEMORY_AND_SWAP_LIMIT="$SF_USER_MEMORY_LIMIT"

	# Use MAX-MEMORY if no other limit is set.
	[[ -z $SF_SHM_SIZE ]] && SF_SHM_SIZE=$SF_USER_MEMORY_LIMIT

	[[ -n $SF_USER_ROOT_FS_SIZE ]] && {
		SF_USER_ROOT_FS_SIZE_NUM="${SF_USER_ROOT_FS_SIZE//[^[:digit:]]/}"
		[[ -z $SF_USER_ROOT_FS_SIZE_NUM ]] && ERREXIT 255 "no digit in SF_USER_ROOT_FS_SIZE="
	}

	SF_MAX_LOAD="$(( ${NPROC:-1} * SF_MAX_STRAIN ))"

	DOCKER_ARGS+=("--memory=${SF_USER_MEMORY_LIMIT}")
	# Setting memory-swap and memory to same value will disable swapping
	DOCKER_ARGS+=("--memory-swap=${SF_USER_MEMORY_AND_SWAP_LIMIT}")
	DOCKER_ARGS+=("--pids-limit=${SF_USER_PIDS_LIMIT}")
	DOCKER_ARGS+=("--cpu-shares=${SF_USER_CPU_SHARE}")
	DOCKER_ARGS+=("--oom-score-adj=${SF_USER_OOM_SCORE}")
	DOCKER_ARGS+=("--blkio-weight=${SF_USER_BLKIO_WEIGHT}")

	[[ -n $SF_USER_DEV_KVM ]] && [[ -n $SF_HAS_DEV_KVM ]] && DOCKER_ARGS+=("--device=/dev/kvm")

	# Mount external filesystem into LG (for android builders who dont need encryption but high IO)
	IFS=' ' read -ra ar <<<"$SF_USER_FS_EXT"
	for str in "${ar[@]}"; do
		IFS=: read -ra arr <<<"$str"
		name=${arr[0]//[^a-z0-9A-Z\/]}
		dst=${arr[1]//[^a-z0-9A-Z\/]}
		str=${arr[2]//[^a-z,]}
		[[ -n $name ]] && [[ -n $dst ]] && [[ -e "/sf/ext/${name}" ]] && DOCKER_ARGS+=("-v${SF_BASEDIR}/data/ext/${name}:${dst}${str:+:$str}")
	done

	if [[ -z $SF_USER_ROOT_FS_SIZE ]]; then
		DOCKER_ARGS+=("--read-only")
	else
		# HERE: Root-FS / is _writeable_ by user.
		[[ ${SF_USER_ROOT_FS_SIZE_NUM} -gt 0 ]] && {
			# HERE: Root-Fs is LIMITED in size
			# These files must be mounted read-only as these are special files
			# for docker and ignored by --opt storage-size= limitations.
			# Backing FS must be of type XFS
			[[ "${SF_BACKING_FS}" != "xfs" ]] && ERREXIT 1 "Backing FS is not XFS but SF_USER_ROOT_FS_SIZE is set"
			DOCKER_ARGS+=("--storage-opt")
			DOCKER_ARGS+=("size=${SF_USER_ROOT_FS_SIZE:?}")
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/etc/hosts:/etc/hosts:ro")
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/db/user/lg-${LID}/hostname:/etc/hostname:ro")
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/etc/resolv.conf:/etc/resolv.conf:ro")
		}
	fi

	# NOTE: This is no longer used because /dev/shm is now mounted as tmpfs to make UML work
	# [[ -n $SF_SHM_SIZE ]] && DOCKER_ARGS+=("--shm-size=$SF_SHM_SIZE")

	[[ -n $SF_SYSBOX ]] && SYSBOX_ARGS+=("--runtime=sysbox-runc")
}

# Publish user limits to self/limits, human readable.
write_guest_limits()
{
	local is_token
	local is_ro
	local tx;

	tx="${SF_USER_UL_RATE}"
	[[ -z $SF_USER_UL_RATE ]] && tx="${SF_MAXOUT}"

	is_token="no"
	[[ -n $SF_TOKEN ]] && is_token="yes"

	[[ -z $SF_USER_ROOT_FS_SIZE ]] && is_ro="read-only"
	tofile "\
TOKEN_USED=${is_token}
CPUS=${SF_CPUS}
ROOT_SIZE=${is_ro:-$SF_USER_ROOT_FS_SIZE}
ROOT_FILES=${is_ro:-$SF_USER_ROOT_FS_INODE}
SEC_SIZE=${SF_USER_FS_SIZE:-unlimited}
SEC_FILES=${SF_USER_FS_INODE:-unlimited}
SHM_SIZE=${SF_SHM_SIZE}
PIDS=${SF_USER_PIDS_LIMIT}
MEMORY=${SF_USER_MEMORY_LIMIT}
NOFILE=${SF_ULIMIT_NOFILE}
TX=${tx:-unlimited}
RX=${SF_MAXIN:-unlimited}
SYN_BURST=${SF_USER_SYN_BURST}
SYN_RATE=${SF_USER_SYN_LIMIT}/sec
FW=${SF_USER_FW}
SERVERS=${SF_LIMIT_SERVER_BY_IP}
GREETINGS='${SF_SYSCOP_MSG}'" "/config/self-for-guest/lg-${LID}/limits"
}

# Write limits to file that can be loaded by other processes (like rpc and encfsd)
write_lg_limits() {
	tofile "\
SF_USER_ROOT_FS_SIZE=\"$SF_USER_ROOT_FS_SIZE\"
SF_USER_ROOT_FS_INODE=\"$SF_USER_ROOT_FS_INODE\"
SF_USER_FS_SIZE=\"$SF_USER_FS_SIZE\"
SF_USER_FS_INODE=\"$SF_USER_FS_INODE\"
SF_USER_UL_RATE=\"$SF_USER_UL_RATE\"
SF_HOSTNAME=\"$SF_HOSTNAME\"
YOUR_COUNTRY_ISO=\"$YOUR_COUNTRY_ISO\"
YOUR_CONTINENT_CODE=\"$YOUR_CONTINENT_CODE\"
YOUR_IP_HASH=\"$YOUR_IP_HASH\"
SF_RPORT=\"$SF_RPORT\"
SF_USER_FW=\"$SF_USER_FW\"
SF_TOKEN_IMMUTABLE=\"$SF_TOKEN_IMMUTABLE\"
SF_USER_IMMUNE=\"$SF_USER_IMMUNE\"" "${LG_RUN_DIR}/limits.txt"
}

check_banned()
{
	local blfn

	[[ ${SF_USER_ALLOW_IP,,} == "any" ]] && return
	[[ -e "${SF_BLACKLIST_DIR}/ip-${YOUR_IP}" ]] && blfn="${SF_BLACKLIST_DIR}/ip-${YOUR_IP}"
	[[ -z $blfn ]] && [[ -e "${SF_BLACKLIST_DIR}/net-${YOUR_IP%\.*}" ]] && blfn="${SF_BLACKLIST_DIR}/net-${YOUR_IP%\.*}"
	[[ -z $blfn ]] && return

	LOG_W "[${GEOSTR}] ${XCDR}BANNED${XCN} (${YOUR_IP}) [$(echo "${*//\\/\\\\}")]\n${CDY}$(<"$blfn")${CN}"
	sleep 10
	echo -e >&2 "${CR}@@@@@ YOUR IP (${YOUR_IP}) HAS BEEN BANNED. Contact us if you feel that this is wrong. @@@@@${CN}"
	if [[ -s "$blfn" ]]; then
		cat "$blfn" >&2
	fi
	sleep 120
	exit 255
}

# wait_for_conn_limit <ID> <ts_window>
# Allow a max of 5 new connections within <ts_window>.
# Give up after 120 seconds.
#   ID - is either "all" for system wide limit or YOUR_IP_HASH for per IP limit
wait_for_conn_limit()
{
	local ts_window
	local id
	local n
	local fn

	id="$1"
	ts_window="$2"
	fn="/dev/shm/conn-${id}.conf"
	# Do not allow more than 5 new connections in 30 seconds.
	ARR=(0 0 0 0 0)
	[[ -f "${fn}" ]] && {
		NOW="$(date +%s)"
		local ts_good
		local c
		c=0
		while :; do
			eval "$(grep ^ARR "${fn}")"

			ts_good=$((NOW - ts_window))
			[[ ${ARR[0]} -lt $ts_good ]] && break

			[[ $c -gt 60 ]] && echo -e >&2 "giving up. Try again later." && exit 255
			[[ $c -eq 0 ]] && echo -e >&2 "[${CY}SF${CN}] Waiting for resources..."
			echo -n "."
			sleep 2
			((c++))
			((NOW+=2))
		done
		[[ $c -gt 0 ]] && echo -e >&2 "[${CG}OK${CN}]"
	}
	tofile "ARR=(${ARR[*]:1:4} $NOW)" "${fn}"
}

wait_for_load()
{
	local load
	local max="$1"
	local n

	while :; do
		read -r -a load </proc/loadavg
		[[ ${load[0]%%.*} -lt "$max" ]] && break
		echo -e >&2 "[${CY}SF${CN}] Waiting for load to go down..."
		sleep 5
		((n++))
		[[ $n -ge 20 ]] && ERREXIT 255 "giving up (load to high)."
	done
}

wait_for_resources()
{
	# 5 Connections within 60 seconds from the same IP.
	wait_for_conn_limit "${YOUR_IP_HASH}" "60" 
	# 5 Connections within 10 seconds all in all
	wait_for_conn_limit "all" "10"

	wait_for_load "${SF_MAX_LOAD}"
}

print_relay_notice()
{
	sleep 5
    echo >&2 -e "\
[${CR}ERROR${CN}]
--> You (${CDY}$YOUR_IP${CN}) are trying to connect from a Relay.
--> Log in from Relays is available for ${CG}VALUED${CN} users only.
--> To log in from Relays please ask us for an ACCESS TOKEN.
--> Read ${CB}${CUL}https://www.thc.org/segfault/free${CN}
--> Contact us: ${CW}https://thc.org/ops${CN}"
	sleep 5
}

# Check if login from Tor is ENABLED.
# TODO: Make this work with the IP hashes
check_relay_status()
{
	local is_relay
	local fn

	# FIXME: If user is allowed to log in via TOR then we should use
	# the TOKEN to limit his number of servers.
	[[ -n $SF_ALLOW_SRC_TOR ]] && return
	if [[ "${YOUR_IP}" == "${SF_TOR_IP}" ]]; then
		is_relay=1
	else
		[[ -f "/sf/share/tor-exit-nodes.txt" ]] && fn+=("/sf/share/tor-exit-nodes.txt")
		[[ -f "/sf/share/relay-exit-nodes-mullvad.txt" ]] && fn+=("/sf/share/relay-exit-nodes-mullvad.txt")
		[[ -f "/config/host/etc/relay-exit-nodes-global.txt" ]] && fn+=("/config/host/etc/relay-exit-nodes-global.txt")
		
		exec_devnull grep -q -Fx "^${YOUR_IP}" "${fn[@]}" && is_relay=1
	fi

	[[ -z $is_relay ]] && return

	print_relay_notice
	LOG_W "RELAY DENIED"
	ERREXIT 255
}

print_timer()
{
	local c
	c=$1

	[[ -z $c ]] && c=10

	echo -e "\e[?25l"
	while [[ $c -gt 0 ]]; do
		echo -ne >&2 "Continuing in $c sec...   "$'\r'
		sleep 1
		((c--))
	done
	echo -e "\e[2K\e[?25h"
}

usermsg()
{
	[[ ! -f "${SF_USER_DB_DIR}/syscop-msg.txt" ]] && return
	[[ -n $SF_HUSHLOGIN ]] && return

	### Show during IS_LOGIN _and_ COMMAND execution but use STDERR
	echo -e >&2 "\
${CDY}@@@@@@@@@@@@@@@@@@ SysCops Message @@@@@@@@@@@@@@@@@@@@@@@${CN}
${CR}$(<"${SF_USER_DB_DIR}/syscop-msg.txt")
${CW}[[[ Contact us on TG and let's talk about our feelings ]]]
${CDY}@@@@@@@@@@@@@@@@@@ SysCops Message @@@@@@@@@@@@@@@@@@@@@@@${CN}"
	echo -en >&2 "\e[?25l"  # Hide cursor
	if [[ -t 0 ]]; then
		print_timer 30
		echo -en >&2 "Press any key to continue."
		read -r -n1
	else
		echo -en >&2 "\e[25lContinuing in 30 seconds..."
		sleep 30
	fi
	echo -en >&2 "\e[?25h"$'\r'

	rm -f "${SF_USER_DB_DIR}/syscop-msg.txt"
}

ERR_NOTHUMAN() {
	sleep 5
    echo -e >&2 "\
💥 You do not seem to be human. Only HUMANS can create ${CDG}NEW SERVERS${CN}.

This check is done ONLY when creating NEW SERVERS. Contact us
if we got this wrong or try one of the following:

- Read ${CB}${CUL}https://thc.org/sf/token${CN} and get a TOKEN.
- Dare interrupt a SysCop and ask for help.
- Connect with SSH from your TERMINAL (not from a script)."

	sleep 15
	ERREXIT 202
}

# Server does not exist _AND_ not an interactive shell.
ERR_NOTEXIST() {
	LOG_W "${XCDG}${SF_HOSTNAME}${XCN} [${GEOSTR}] No such server [${XCDC}${XCF}$(echo "${*//\\/\\\\}")${XCN}]"
	sleep 5
	echo -e >&2 "\
💥 The server ${CDM}${SF_FQDN%%\.*}-${SF_HOSTNAME}${CN} does not exist
at the domain ${CDM}${SF_FQDN}${CN}.

Please check that you are connecting to the correct domain where your
server has been created (it was not at ${SF_FQDN}).

Please supply the correct ${CDY}SECRET${CN}:

   ${CDY}ssh -o SetEnv SECRET=ChangeMeSecretHere root@${SF_FQDN}${CN}"

	sleep 55
	do_exit 203
}

do_new_server_human() {
    local R
    local IFS
    local arr
    [[ -z $SF_NEW_SERVER_HUMAN ]] && return

    # Check for valid TTY
    [[ ! -t 0 ]] && ERR_NOTHUMAN

    # WebShell does not support ANSI/resize sequence
    [[ -n $SF_IS_WEBSHELL ]] && return

	# Windows cmd.exe terminal does not support ansi escape codes :/ Cant use this
	# trick.
    # stty -echo
    # printf "\033[18t"
    # read -t 5 -rdt R
    # stty echo
    # R="${R//[^0-9;]/}"
    # [[ "${#R}" -gt 10 ]] && ERR_NOTHUMAN

    # IFS=';' read -r -a arr <<< "$R"
    # [[ "${arr[1]}" -le 0 || "${arr[1]}" -ge 800 ]] && ERR_NOTHUMAN # COLS
    # [[ "${arr[2]}" -le 0 || "${arr[2]}" -ge 600 ]] && ERR_NOTHUMAN # ROWS
}

do_new_server_delay() {
	local R
    [[ -z "$SF_NEW_SERVER_DELAY" ]] && return

    echo -en "\
${CDB}----------------------------------------------------------------------${CN}
You are using the ${CDY}FREE TIER${CN} without a ${CDY}TOKEN${CN}. Various ${CR}restrictions${CN}
apply:

- You have to wait ${CDG}${SF_NEW_SERVER_DELAY}${CN} seconds ❤️
- Your network traffic is ${CDG}metered${CN} and at ${CDG}snail speed${CN} 🙈
- Your ${CDG}CPU power${CN} and memory are limited 🙉
- Your server is subject to ${CDG}automated ban${CN} 🙊
- Your server will ${CDG}shut down${CN} on log out 💩

Read 👉 ${CB}${CUL}https://thc.org/sf/token${CN} 👈 to remove these restrictions. ❤️

After login, see your restrictions by typing: ${CDC}cat /config/self/limits${CN}
${CDB}----------------------------------------------------------------------${CN}
Read ${CB}${CUL}https://thc.org/sf/faq${CN} as well. 📖
${CDB}----------------------------------------------------------------------${CN}
"

    print_timer "$SF_NEW_SERVER_DELAY"
    echo -en >&2 "Press any key to continue (you have 10 seconds)."
    read -t10 -r -n1 R || {
        echo -e "\
\nDARN. You did not press 'any key' within 10 seconds after the time expired. Try again.\

...or GET A TOKEN: ${CB}${CUL}https://thc.org/sf/token${CN}
"
        sleep 15
        ERREXIT 205 "[${GEOSTR}] ETIME: User did not press key within 10 seconds"
    }
	echo ""
}

do_new_server_limit() {
    do_new_server_human
    do_new_server_delay
}

# Check if max servers per IP are in use.
check_limit_server_by_ip()
{
	local fn
	local arr_new
	local str

	[[ -z $SF_LIMIT_SERVER_BY_IP ]] && return
	[[ -n $SF_IS_PAYING ]] && return

	[[ -n $IS_TRY_EXISTING ]] && {
		# SECRET= was supplied.
		# If it's running then allow to connect to existing (it's not a new server).
		exec_devnull docker container inspect "lg-${LID}" -f '{{.State.Status}}' && return
	}

	fn="/dev/shm/ip-${YOUR_IP_HASH}.conf"

	[[ ! -f "$fn" ]] && {
		tofile "ARR=($LID)" "$fn"
		return
	}

	eval "$(grep ^ARR "$fn")"

	local n
	local lid
	n=0
	for lid in "${ARR[@]}"; do
		[[ -z $lid ]] && break
		### Check if any of the shells are still alive
		str="$(exec_errnull docker container inspect "lg-${lid}" -f '{{.State.Status}}')" || continue

		# Container can be in "Created" state (reason is unknown)
		[[ "$str" != "running" ]] && {
			# FIXME: A rare race condition (which in worst case terminates the shell)
			# when a container was recently created and a user creates another server
			# before the old container entered RUNNING state. Disregard this scenario.
			exec_devnull docker stop "lg-${lid}"
			continue
		}
		((n++))
		arr_new+=("$lid")
	done

	## Eyy, good idea to check if they are idle?
	[[ "$n" -ge "${SF_LIMIT_SERVER_BY_IP}" ]] && {
		print_to_many_servers
		LOG_W "[${GEOSTR}] TO MANY SERVERS FOR ${YOUR_IP}"
		do_exit 254
	}

	[[ "$((n+1))" -ge "${SF_LIMIT_SERVER_BY_IP}" ]] && [[ -z $HUSHLOGIN ]] && [[ -n $IS_LOGIN ]] && IS_SHOW_LAST_SERVER="$((n+1))"

	[[ "$n" -ge 1 ]] && {
		# The 2nd and further servers from the same IP get less CPU share
		SF_USER_CPU_SHARE=2
		SF_USER_OOM_SCORE=1000
		SF_USER_NICE_SCORE=19
		SF_USER_BLKIO_WEIGHT=10
		# DEBUGF "${n}. server from ${YOUR_IP}. CPU_SHARE=${SF_USER_CPU_SHARE}, OOM=${SF_USER_OOM_SCORE}."
	}

	tofile "ARR=(${arr_new[*]} $LID)" "$fn"
}

# We must not request the guest's IP over the network (leakage). The best we can do is
# lookup his IP in a local database.
mk_geoip()
{
	local ip
	local country
	local country_iso
	local continent_code
	ip="${1}"
	[[ ! -f /sf/share/GeoLite2-City.mmdb ]] && return
	[[ -z ${ip} ]] && return

	local city
	local country
	res=$(mmdbinspect --db /sf/share/GeoLite2-City.mmdb "${ip}")
	[[ -z $SF_HIDEIP ]] && city=$(echo "$res" | jq -r '.[0].Records[0].Record.city.names.en | select(. != null)')
	country=$(echo "$res" | jq -r '.[0].Records[0].Record.country.names.en | select(. != null)')
	country_iso=$(echo "$res" | jq -r '.[0].Records[0].Record.country.iso_code | select(. != null)')
	continent_code=$(echo "$res" | jq -r '.[0].Records[0].Record.continent.code | select(. != null)')

	country_iso="${country_iso,,}"
	country_iso="${country_iso//[^a-z]}"
	YOUR_COUNTRY_ISO="${country_iso:0:2}"

	continent_code="${continent_code,,}"
	continent_code="${continent_code//[^a-z]}"
	YOUR_CONTINENT_CODE="${continent_code:0:6}"

	unset YOUR_GEOIP
	if [[ -n $city ]] && [[ -n $country ]]; then
		YOUR_GEOIP="${city}/${country}"
	elif [[ -n $city ]] || [[ -n $country ]]; then
		YOUR_GEOIP="${city}${country}" # Either one but not both
	fi
	GEOSTR="${XCF}${YOUR_IP_HASH}${XCN}/${XCDY}${YOUR_COUNTRY_ISO}${XCN}/${XCDM}${YOUR_CONTINENT_CODE}${XCN}"
}

sysmsg()
{
	local fn
	fn="$1"

	[[ ! -f "$1" ]] && return
	eval "$(<"$fn")"
}

# Instruct docker to assign TTY if input is a TTY (ssh -t <user@host> <command>)
DOCKER_EXEC_ARGS=("-i")
if [[ -t 0 ]]; then
	# Disable SIGINT and SIGSTP. Use 'trap' first as 'stty' can be interrupted itself!
	trap "" SIGINT
	stty -isig
	DOCKER_EXEC_ARGS=("-it")
fi

if [[ ${#} -eq 2 ]]; then
	# HERE: command via "-c" "cmd"
	PARAM=("-c" "${2}");
elif [[ ${#} -eq 0 ]]; then
	# - Set docker arguments to login-shell or profile wont get read.
	PARAM=("-il")
	# For -c "cmd" we silence output but for login shells we show
	IS_LOGIN=1
else
	ERREXIT 255 "BAD PARAMS: '${*}'"
fi

### ----BEGIN SANTIZE----
[[ -n $HUSHLOGIN ]] && { SF_HUSHLOGIN=1; DOCKER_EXEC_ARGS+=("--env" "SF_HUSHLOGIN=1"); }
[[ -n $HIDEIP ]] && SF_HIDEIP=1
[[ -n $SF_DEBUG ]] && SF_DEBUG=1

[[ -n $SF_IS_ASKSECSH ]] && {
	# login to secret@ to prompt for SECRET
    unset err
    while :; do
        echo -e -n "\U1F480 ${CDY}SECRET${CN}: ${CDC}"
        read -r -n128 -t30 SECRET || err=1
        echo -en "${CN}"
        [[ -n $err ]] && exit 255
        SECRET="${SECRET//[^0-9a-zA-Z-]}"
		SECRET="${SECRET##*-}"  # Remove host part 'lsd-ABCD...'
        [[ ${#SECRET} -eq 24 ]] && break
        [[ "$SECRET" == exit ]] && exit 0
        [[ "$SECRET" == new ]] && { unset SECRET; break; }
        echo -e "${CDR}ERROR${CN}: Must be 24 characters. Type ${CDC}exit${CN} to exit or ${CDC}new${CN} to generate."
    done
}
# SECRET and SF_DEBUG are user supplied.
# Connect to existing session

if [[ -n $SECRET ]]; then
	SECRET="${SECRET//[^a-zA-Z0-9-]}"
	SECRET="${SECRET##*-}"  # Remove host part 'lsd-ABCD...'
	[[ ${#SECRET} -eq 24 ]] && {
		IS_TRY_EXISTING=1
		SF_SEC="${SECRET}"
	}
fi
[[ -z $SF_SEC ]] && SF_SEC="$(head -c 1024 /dev/urandom | tr -dc '[:alpha:]' | head -c 24)"

[[ -n $SF_IS_WEBSHELL ]] && {
	# Correct YOUR_IP
	REMOTE_ADDR="${REMOTE_ADDR//[^0-9.:]}"
	[[ -z $REMOTE_ADDR || ${#REMOTE_ADDR} -gt 32 ]] && ERREXIT "Bad REMOTE_ADDR: len=${#REMOTE_ADDR}"
	YOUR_IP="${REMOTE_ADDR}"
}

[[ -n $PRJ ]] && {
	SF_PRJ="${PRJ//[^a-zA-Z0-9._]}"
	SF_PRJ="${SF_PRJ:0:32}"
	# Compat mode to add DNS via PRJ
	[[ -z $DNS ]] && [[ ! $SF_PRJ =~ [^0-9.] ]] && { DNS="$SF_PRJ"; unset SF_PRJ; }
}

# Users can then use DNSChef and play with DNS MitM or redirect DNS requests to
# wiretap'ed internal networks.
[[ -n $DNS ]] && {
	SF_USER_DNS="${DNS//[^0-9.]}"
	SF_USER_DNS="${SF_USER_DNS:0:32}"
}

[[ -n $TOKEN ]] && {
	SF_TOKEN="${TOKEN//[^a-zA-Z0-9@]}"
	# TOKEN=User@foobarBLah.helloAbc => foobarBLahhelloAbc
	SF_TOKEN="${TOKEN##*@}"
	SF_TOKEN="${SF_TOKEN:0:32}"
}
# Unset user supplied env variables
unset SECRET HUSHLOGIN HIDEIP PRJ TOKEN DNS
### ----END SANITIZE----

# Only output progress if this is a login shell _and_ not HUSHLOGIN
[[ -n $IS_LOGIN ]] && [[ -z $SF_HUSHLOGIN ]] && echo_pty() { echo "$@"; }

# Note: sha512sum outputs hex. The first character is always [0..9a..f].
# The base64 encoding means the LID will always start with N..Z.
LID=$(echo -n "LID ${SF_SEC}" | sha512sum | base64 -w0)
LID="${LID//[^[:alpha:]]}"
LID="${LID:0:10}"
export LID

[[ -z $SF_SEED ]] && ERREXIT 244 "SF_SEED= is not set."

# Call init_vars() after LID is set
init_vars

# Get GeoIP, Country and Continent
mk_geoip "${YOUR_IP}"
# Load CPU/PID/OOM limits (systemwide or user specific)
load_limits
# Check if IP is banned
check_banned "$@"

mk_hostname

write_lg_limits

# Show system messages
sysmsg "/config/host/etc/loginmsg-all.sh"

HNLID_FILE="${HNLID_DIR}/hn2lid-${SF_HOSTNAME}"
# LG_SEM is created in docker_sshd.sh
LG_SEM="sema:lg-bucket-$(( (SF_NUM + SF_RAND_OFS) % SF_HM_SIZE_LG ))"

# Keep guest waiting until there are sufficient resources
wait_for_resources

# Check if connects originates from a Relay
check_relay_status

### Check if the limit has been reached for this source IP
check_limit_server_by_ip

# Check if share got unmounted (e.g. EncFS died)
[[ ! -f "${SF_SEC_DIR}/.IS-ENCRYPTED" ]] && ERREXIT 243 "System not ready yet (wrong EncFS password. Please inform the admin to set correct SF_SEED)"


# Execute under "root" (uid=1001) context:
[[ ! -d "${HNLID_DIR}" ]] && { mkdir -p "${HNLID_DIR}" || ERREXIT; }

# Output user messages and wait for enter....
usermsg

if [[ -d "${SF_USER_DB_DIR}" ]]; then
	S="Your Server       : ${CDY}${SF_HOSTNAME:0:34}${CN}....................................................."
	echo_pty -en "${S:0:65}"
	touch "${HNLID_FILE}"
else
	[[ -z "$IS_LOGIN" ]] && ERR_NOTEXIST "$@"
	print_disclaimer
	sysmsg "/config/host/etc/loginmsg-new.sh"
	do_new_server_limit
	# ######################################################################
	# 70 long
	# Got 54 space
	# Creating Server => 16 chars
	# Color escape codes => 11 chars
	# Hostname max = 54 - 16
	# Final echo: 54 + 11
	S="Creating Server ${CDY}${SF_HOSTNAME:0:38}${CN}..................................................."
	echo_pty -en "${S:0:65}"

	# Check for collision where different SECRETs generates the same (and already existing) SF_NUM / SF_HOSTNAME:
	[[ -f "${HNLID_FILE}" ]] && [[ "$(<"${HNLID_FILE}")" != "${LID}" ]] && ERREXIT 69 "Collision. Wrong SECRET for $SF_HOSTNAME."
	SF_IS_NEW_SERVER=1
	DOCKER_EXEC_ARGS+=("--env" "SF_IS_NEW_SERVER=1")

	mkdir -p "${SF_USER_DB_DIR}" || ERREXIT
	touch "${SF_USER_DB_DIR}/created.txt" || ERREXIT
	tofile "$SF_NUM" "${SF_USER_DB_DIR}/num"
	tofile "$SF_HOSTNAME" "${SF_USER_DB_DIR}/hostname"
	[[ -d "${HNLID_DIR}" ]] || exec_devnull mkdir "${HNLID_DIR}"
	tofile "$LID" "${HNLID_FILE}" || ERREXIT 231 "tofile: Failed to create hnlid_file"
	# Add a log entry into elastisearch using logpipe
	logpipe "Type:Create|LID:${LID}|Hostname:${SF_HOSTNAME}|IPHASH:${YOUR_IP_HASH}|C_ISO:${YOUR_COUNTRY_ISO^^}|CONTINENT=${YOUR_CONTINENT_CODE}|"
fi

DEBUGF "LID=${LID} SF_HOSTNAME=${SF_HOSTNAME}"
unset str
[[ -n $SF_LOG_IP ]] && str="[${XCDY}${YOUR_IP}${XCN}] "
str+="${XCDG}${SF_HOSTNAME}"
[[ -n $SF_PRJ ]] && str+="/${XCW}${SF_PRJ}"
LOG "${str}${XCN} [${GEOSTR}] ${XCDC}$(echo "${*//\\/\\\\}")${XCN}"
unset str

# Record which SSHD process is connect to guest LG.
tofile "SSHD_PID=${SSHD_PID}
LID=$LID" "${LG_PID_FILE}"
touch "${TS_LOGIN_FILE}"
touch "${IS_LOGGED_IN_FILE}"

# Create EncFS password
encfspass=$(echo -n "EncFS-PASS-${SF_SEED}${SF_SEC}" | sha512sum | base64 -w0)
encfspass="${encfspass//[^[:alpha:]]}"
encfspass="${encfspass:0:24}"
[[ -z $encfspass ]] && ERREXIT 241 "Failed to create session password"

# Start & Wait for EncFS
res=$(echo -e "RPUSH encfs \"$$ ${LID} M ${encfspass}\"\n\
BLPOP \"encfs-$$-${LID}-M\" 20" | red) || ERREXIT 230 "Can't reach EncFSD"
echo_pty -n "...."

# Only one LG at a time (and wait any other connection to call 'docker exec' until it's fully running.
sem_wait

# Attach to container if already running
[[ -n $IS_TRY_EXISTING ]] && {
	# If state is not running then stop it.
	str="$(exec_errnull docker container inspect "lg-${LID}" -f '{{.State.Status}}')" && {
		[[ $str == "running" ]] && {
			echo_pty -e "..........[${CG}Ok${CN}]"
			DEBUGF "Attaching to existing container lg-${LID}..."
			# LOG "Attaching to existing container"
			spawn_shell_exit "$@"
			# NOT REACHED
		}
		LOG "Container not in RUNNING state."
		# HERE: Container exists but not in RUNNING state.
		exec_devnull docker stop "lg-${LID}"
	}
	DEBUGF "FAILED to attached to lg-${LID}"
	# HERE: Container does not exists.
}

### Create ONION directory => From within encfsd (to set XFS quota)

# Starting GUEST shell
# Challenge: Keep user processes running that got spawned in the background
# even when first container terminates. Also do not terminate container
# when there are still shells using it ('docker exec').
# Solution: Spawn a container in the background and always use 'docker exec' to
# create a shell for the user.

# Use --init so that 2nd shell to same container keeps running even if 1st shell
# exits.
### Start the care taker...
selfdir="/config/self-for-guest/lg-${LID}"
xmkdir "${selfdir}"
[[ -n $SF_TOKEN ]] && tofile "${SF_TOKEN}" "/config/self-for-guest/lg-${LID}/token"
write_guest_limits

# Note: cgroup-parents: with cgroup-v1 the full path needs to be specified (e.g. sf.slice/sf-guest.slice) whereas with
# cgroup-v2 only sf-guest.slice need to be specified.
[[ -n $SF_IS_GOLD_PROMPT ]] && export SF_IS_GOLD_PROMPT
[[ -n $SF_PRJ ]] && export SF_PRJ
[[ -n $SF_DEBUG ]] && export SF_DEBUG
[[ -z $SF_USER_DNS ]] && SF_USER_DNS="$SF_DNS"
# exec_devnull docker run --runtime=sysbox-runc \
exec_devnull docker run \
	"${SYSBOX_ARGS[@]}" \
	--hostname "${SF_FQDN%%.*}-${SF_HOSTNAME}" \
	"${DOCKER_ARGS[@]}" \
	--rm \
	--init \
	--cpus="${SF_CPUS}" \
	--cgroup-parent "${SF_CG_PARENT:?}" \
	--workdir=/ \
	--ulimit nofile="${SF_ULIMIT_NOFILE}" \
	--name "lg-${LID}" \
	--cap-drop=MKNOD \
	--net sf-guest \
	--add-host tor:"${SF_TOR_IP}"                           `# No effect when /etc/hosts is mounted read-only` \
	--add-host router:"${SF_NET_LG_ROUTER_IP}"              `# No effect when /etc/hosts is mounted read-only` \
	--add-host dns:"${SF_DNS}"                              `# No effect when /etc/hosts is mounted read-only` \
	--add-host rpc:"${SF_RPC_IP}"                           `# No effect when /etc/hosts is mounted read-only` \
	--add-host sf:"${SF_RPC_IP}"                            `# No effect when /etc/hosts is mounted read-only` \
	--add-host segfault:"${SF_SSHD_IP:?}"                   `# No effect when /etc/hosts is mounted read-only` \
	--add-host segfault.net:"${SF_SSHD_IP}"                 `# No effect when /etc/hosts is mounted read-only` \
	--add-host "${SF_FQDN}:${SF_SSHD_IP}"                   `# No effect when /etc/hosts is mounted read-only` \
	--add-host "${SF_FQDN%%.*}:${SF_SSHD_IP}"               `# No effect when /etc/hosts is mounted read-only` \
	--dns "${SF_USER_DNS:-BAD}" \
	--env SF_SEC="${SF_SEC}" \
	--env SF_TOR_IP="${SF_TOR_IP}" \
	--env TOR="${SF_TOR_IP}:9050" \
	--env SF_USER="${SF_USER}" \
	--env SF_FQDN="${SF_FQDN}" \
	--env SF_HOSTNAME="${SF_HOSTNAME}" \
	--env SF_LID="${LID}" \
	-e SF_PRJ \
	-e SF_IS_GOLD_PROMPT \
	-e SF_DEBUG \
	--log-driver "${SF_DOCKER_LOG}" \
	--tmpfs /tmp:exec,size="${SF_SHM_SIZE:-64m}"            `# GoLang needs /tmp to be executeable ` \
	--tmpfs /dev/shm:exec,size="${SF_SHM_SIZE:-64m}"        `# UML needs /dev/shm to be executeable` \
	--sysctl net.ipv6.conf.all.disable_ipv6=0               `# Allow IPv6 (used by WireGuard FOBs) ` \
	--sysctl net.ipv4.tcp_tw_reuse=1                        `# Immediately reuse TIME_WAIT sockets ` \
	--sysctl net.ipv4.tcp_fin_timeout=10 \
	-v "${SF_BASEDIR}/data/share/:/sf/share:ro" \
	-v "${SF_CFG_GUEST_DIR:?}/:/config/guest:ro" \
	-v "${SF_GUEST_SELFDIR:?}/lg-${LID}:/config/self:ro,slave" \
	-v "${SF_ENCFS_SEC_DIR}/lg-${LID}:/sec:slave" \
	-v "${SF_ENCFS_SEC_DIR}/everyone-root/everyone:/everyone:ro,slave" \
	-v "${SF_ENCFS_SEC_DIR}/everyone-root/everyone/${SF_HOSTNAME}:/everyone/${SF_HOSTNAME}:slave"  `# Mount myself RW over RO` \
	-v "${SF_ENCFS_SEC_DIR}/www-root/www/${SF_HOSTNAME,,}:/onion:slave" \
	"${LXCFS_ARGS[@]}" \
	--user 1000:1000 \
	-d \
	"sf-guest${SF_GUEST_CONTAINER_NAME_SUFFIX}" bash -c "exec -a '[init-${LID}-${SF_HOSTNAME}]' sleep infinity" || ERREXIT 251 "Failed-#1 to set up guest container..."
# Note: Run 'init/sleep' as user 1000:1000 so that sf-host's SSHD can move itself into this guest's
# network namespace. 

echo_pty -n ".."
DEBUGF "Container started..."
touch "${TS_RUN_FILE}"

# Wait for detached docker shell to enter 'running' state
n=0
while :; do
	str="$(exec_errnull docker container inspect "lg-${LID}" -f '{{.State.Status}}')" && {
		[[ "$str" == "running" ]] && break
	}
	DEBUGF "#${n} Waiting for sf-guest to be ready..."
	if [[ $n -gt 0 ]]; then sleep 5; else sleep 0.1; fi
	n=$((n+1))
	[[ $n -gt 2 ]] && STOPEXIT "${LID}" 253 "Could not create container..."
done
echo_pty -n ".."
# LOG "Container started & RUNNING..."

arr=($(docker inspect -f '{{.Id}} {{.State.Pid}} {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}} {{ (index .NetworkSettings.Networks "sf-guest").MacAddress }}' "lg-${LID}"))
CID=${arr[0]}
LG_PID=${arr[1]}
C_IP=${arr[2]}
LG_MAC=${arr[3]}
[[ -z $C_IP ]] && ERREXIT 249 "[${LID}] ${SF_FQ_HOSTNAME} Could not get container's IP address."

IDX=$((0x${YOUR_IP_HASH} % 1024))
[[ $IDX -lt 0 ]] && IDX=$((IDX * -1))
tofile "\
SYN_LIMIT='${SF_USER_SYN_LIMIT}'
SYN_BURST='${SF_USER_SYN_BURST}'
LG_IP_HASH='${YOUR_IP_HASH}'
IDX='${IDX}'
USER_DL_RATE='${SF_USER_DL_RATE}'
USER_UL_RATE='${SF_USER_UL_RATE}'
CID='${CID}'
LG_PID='${LG_PID:?}'
LG_MAC='${LG_MAC:?}'
C_IP='$C_IP'" "${LG_RUN_DIR:?}/config.txt"

# Set up Root FS / inode limits and move encfsd to lg's cgroup
setup_encfsd || STOPEXIT "${LID}" 244 "[${LID}] ${SF_FQ_HOSTNAME} Could not set FS quota."
echo_pty -n ".."

# Store LG information in Redis
res=$(red SET "ip:${C_IP}" "${LID} ${CID} ${LG_PID}") || STOPEXIT "$LID" 252 "[${LID}] ${SF_FQ_HOSTNAME} Failed to set LID in Redis"

# Ready container
exec_devnull docker exec sf-master /ready-lg.sh "${LID}" || STOPEXIT "${LID}" 246 "[${LID}] ${SF_FQ_HOSTNAME} Failed-#3 to ready guest container..."

# Setup container (within container's namespace)
unset WGNAME_UP
[[ -s "${SF_USER_DB_DIR}/wg/name_up" ]] && WGNAME_UP="$(<"${SF_USER_DB_DIR}/wg/name_up")"
exec_devnull timeout 5 docker exec --user 0:0 --env SF_IS_NEW_SERVER="${SF_IS_NEW_SERVER}" --env WGNAME_UP="${WGNAME_UP}" "lg-${LID}" /sf/bin/sf-setup.sh || STOPEXIT "${LID}" 247 "[${LID}] ${SF_FQ_HOSTNAME} Failed-#2 to set up guest container..."
touch "/config/self-for-guest/lg-${LID}/THIS-DIRECTORY-IS-IN-MEMORY-ONLY"
tofile "${C_IP:?}" "/config/self-for-guest/lg-${LID}/c_ip"

echo_pty -e "....[${CG}OK${CN}]"

# Spawn shell
spawn_shell_exit "$@"
# NOT REACHED

