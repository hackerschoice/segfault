#! /bin/bash -r

# This is called by SSHD inside SF-HOST docker.
# - All environments have been cleared by SSHD.
# - Redirects not allowed in restricted shells.
# - bash's 'source' is prohibited (use 'eval' instead)
# - This script might be executed inside the LG's network namespace
#   (if 'ssh -M -S ~/.ssh/foobar' and 'ssh -S ~/.ssh/foobar' is used for multiplexing/Mastering)
#
# This script can be run from the source directory for testing.
# SF_BASEDIR must point to the source directory.
#    su - sf-user
#    export SF_BASEDIR=/home/sf-user/x/segfault-0.2.2a
#    cd /segfault/host/fs-root/bin
#    SF_DEBUG=1 SF_EMU=1 SF_SEED=foobar3 ./segfaultsh

# Load/restore environment variables from file
# SF_DEBUG can be set by ssh-client with -o SetEnv SF_DEBUG=1 or by
# docker compose '.env' file.
SSH_SF_DEBUG="${SF_DEBUG}" # Set by SSH client
[[ -f /dev/shm/env.txt ]] && eval "$(</dev/shm/env.txt)"
[[ -z $SF_DEBUG ]] && SF_DEBUG="${SSH_SF_DEBUG}"
unset SSH_SF_DEBUG
eval "$(</sf/bin/funcs_redis.sh)" || exit
# Debug Trace. see sf_trace-DISABLED
[[ -f /bin/sf_trace ]] && eval "$(</bin/sf_trace)"

[[ -t 1 ]] && {
CY="\e[1;33m" # yellow
CDY="\e[0;33m" # yellow
CR="\e[1;31m" # red
CB="\e[1;34m" # blue
CC="\e[1;36m" # cyan
CG="\e[1;32m" # green
CDG="\e[0;32m" # green
CDC="\e[0;36m" # cyan
CDR="\e[0;31m" # red
CDM="\e[0;35m" # magenta
CN="\e[0m"    # none
CW="\e[1;37m" # white
CF="\e[2m"    # faint
CUL="\e[4m"
CRY="\e[0;33;41m"  # YELLOW on RED (warning)
}

# [PREFIX] [MSG]
_log()
{
	local str
	local p
	p=$1
	shift 1

	[[ -z $IS_LOGGING ]] && return

	# Replace ' with '"'"'
	str="${*//\'/\'\"\'\"\'}"
	# NOTE: segfault.log must be owned 1000:1000
	bash -c "{ echo -en '[$(date '+%F %T' -u)]${p:- }'; echo -e '[${CDM}${LID}${CN}] $str';} 2>/dev/null >>'/sf/run/logs/segfault.log'"
}

LOG(){ _log "" "$@"; }
LOG_E() { _log " ${CR}ERROR${CN} " "$@";}
LOG_W() { _log " ${CDY}WARN${CN} " "$@";}

# NOTE: This function might get called from ERREXIT and before all variables are set.
logout()
{
	local fn
	local pid
	local is_last
	# bash signal race condition: Might be called twice if signal arrives while
	# in this function.
	trap '' SIGHUP
	trap '' SIGTERM
	trap '' SIGPIPE
	[[ -f "${LG_PID_FILE}" ]] && rm -f "${LG_PID_FILE:?}"
	[[ -d "${SF_USER_DB_DIR}" ]] && touch "${TS_LOGOUT_FILE:?}"

	[[ -n $LG_PID_DIR ]] && [[ -n $LID ]] && {
		# Delete IS_LOGGED_IN_FILE if this is the last session to exit.
		is_last=1
		for fn in "${LG_PID_DIR}/pid-${LID}."*; do
			[[ ! -f "$fn" ]] && break # No pid file exists for this LID
			pid=${fn##*.}
			[[ ! -d "/proc/${pid}" ]] && {
				# Happens when 'Failed to set up guest instance' is triggered.
				LOG_E "Stale: pid-${LID}.${pid} [removed]"
				rm -f "${fn}" 
				continue
			}
			unset is_last
		done
	}

	[[ -n $is_last ]] && {
		# LOG "Last PID"
		[[ -f "${IS_LOGGED_IN_FILE:?}" ]] && rm -f "${IS_LOGGED_IN_FILE}"
	}
}

sem_wait()
{
	IS_SEM_WAIT=1
	redq BLPOP "${LG_SEM:?}" 5 || ERREXIT 238 "Could not get lock: ${LG_SEM}"
}

sem_release()
{
	[[ -z $IS_SEM_WAIT ]] && return
	echo -e "DEL '${LG_SEM}'\nRPUSH '${LG_SEM}' 1" | red1 || ERREXIT 237 "Could not release lock: ${LG_SEM}"
	unset IS_SEM_WAIT
}

ERREXIT()
{
	local code
	code="$1"
	[[ -z $code ]] && code=99

	LOG_E "$@"
	shift 1
	[[ -n $1 ]] && echo -e >&2 "${CR}ERROR:${CN} $*"

	sem_release
	logout
	exit "$code"
}

STOPEXIT()
{
	local l
	l="$1"

	shift 1
	exec_devnull docker stop "lg-${l}"
	ERREXIT "$@"
}

if [[ -z $SF_DEBUG ]]; then
	DEBUGF(){ :;}
	SF_DOCKER_LOG="none"
else
	DEBUGF(){ echo -e 1>&2 "${CY}DEBUG:${CN} $*";}
	SF_DOCKER_LOG="local"
fi

argv2esc()
{
	local s
	local x
	local str

	for x in "$@"; do
		# Esacpe ' with '"'"'
		str="${x//\'/\'\"\'\"\'}"
		s+=" '$str'"
	done

	echo "$s"
}

# The current 'restricted shell' does not allow for stdout redirection to /dev/null.
# Thus execute in unrestricted shell with 'exec_devnull' and redirect stdout to /dev/null. 
exec_devnull()
{
	local argstr
	local bin

	bin="$1"
	shift 1

	argstr="$(argv2esc "$@")"
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec \"$bin\" $argstr 2>/dev/null >/dev/null"
	else
		# DEBUGF "EXEC \"$bin\" $argstr"
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		bash -c "exec \"$bin\" $argstr"
	fi
}

exec_errnull()
{
	local argstr
	local bin

	bin="$1"
	shift 1

	argstr="$(argv2esc "$@")"
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec \"$bin\" $argstr 2>/dev/null"
	else
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		bash -c "exec \"$bin\" $argstr"
	fi
}

# Overcoming a restricted shell. Write $1 to file in $2
# tofile "foobar \$HOME \"|';id;" world.txt
tofile()
{
	local str
	# Replace ' with '"'"'
	str="${1//\'/\'\"\'\"\'}"
	bash -c "echo '$str' 2>/dev/null >'$2'"
}

# Set $1 to $2 if $1 is not already set.
emu_set_env()
{
	eval "[[ -n \"\$$1\" ]]" && return
	echo "[+] EMULATION: Setting $1=$2"
	eval "$1"=\""${2}"\"
}

init_emu_tor()
{
	local fn
	fn="${SF_CFG_GUEST_DIR}/onion_hostname-$1"

	[[ -e "$fn" ]] && return

	local str
	str="${1}-EMULATIONxxxxxalsdjfkljasdflkasdlkfjaldsfadlsgiahfgljzhfkawhrkt"
	tofile "${str:0:56}.onion" "${fn}"
}


xmkdir()
{
	[[ -d "$1" ]] && return
	mkdir -p "$1"
}

# segfaultsh started directly from the command shell (for testing & development)
# SF_BASEDIR=/home/sf-user/segfault-src
# SF_EMU_PREFIX="${SF_BASEDIR}/emu"
# mkdir "$SF_EMU_PREFIX"
# SF_DEBUG=1 SF_SEED=foobar3 ./segfaultsh
init_emu()
{
	[[ -z $SF_EMU ]] && return

	SF_EMU_DIR="${SF_BASEDIR}/emu"
	SF_SEC_DIR="${SF_BASEDIR}/emu/sec/www-root"
	SF_CONFIG_DIR="${SF_BASEDIR}/emu/config"
	SF_ETCSF_DIR="${SF_BASEDIR}/config/etc/sf"
	SF_HOST_FS_ROOT="${SF_BASEDIR}/host/fs-root"
	# SF_WWW_ROOT_DIR="${SF_EMU_DIR}/encfs-sec/www-root"


	[[ ! -d $SF_EMU_DIR ]] && mkdir "${SF_EMU_DIR}"

	[[ ! -d "${SF_SEC_DIR}" ]] && mkdir -p "${SF_SEC_DIR}"
	[[ ! -f "${SF_SEC_DIR}/.IS-ENCRYPTED" ]] && touch "${SF_SEC_DIR}/.IS-ENCRYPTED"

	emu_set_env SF_DNS "1.1.1.1"
	emu_set_env SF_FQDN "EMULATION.segfault.net"
	emu_set_env SF_TOR_IP "10.0.0.111"
	emu_set_env SF_USER "root"
	emu_set_env SSH_CONNECTION "1.2.3.4 31337 10.0.2.15 22"
	export SSH_CONNECTION

	# Overwrite defaults to run in EMULATOR
	SF_CFG_GUEST_DIR="${SF_EMU_DIR}/config-for-guest"
	SF_GUEST_SELFDIR="${SF_EMU_DIR}/self-for-guest"
	SF_ENCFS_SEC_DIR="${SF_EMU_DIR}/encfs-sec"

	xmkdir "${SF_ENCFS_SEC_DIR}"
	xmkdir "${SF_CFG_GUEST_DIR}"
	xmkdir "${SF_ENCFS_SEC_DIR}/lg-${LID}"
	xmkdir "${SF_ENCFS_SEC_DIR}/everyone-root"
	xmkdir "${SF_ENCFS_SEC_DIR}/everyone-root/everyone"
	xmkdir "${SF_ENCFS_SEC_DIR}/www-root/www/${SF_HOSTNAME,,}"

	[[ ! -f "${SF_CFG_GUEST_DIR}/id_ed25519" ]] && ssh-keygen -q -t ed25519 -C "" -N "" -f "${SF_CFG_GUEST_DIR}/id_ed25519"
	[[ -f "${SF_CFG_GUEST_DIR}/id_ed25519.pub" ]] && rm -f "${SF_CFG_GUEST_DIR}/id_ed25519.pub"

	init_emu_tor 22
	init_emu_tor 80

	exec_devnull docker network create -d bridge sf-guest
}

init_defaults()
{
	[[ -z $SF_BASEDIR ]] && ERREXIT 1 "SF_BASEDIR= not set"
	SF_SEC_DIR="/sec/www-root"
	# SF_WWW_ROOT_DIR="/sec/www-root"
	SF_CONFIG_DIR="/config/host"
	SF_ETCSF_DIR="/config/host/etc/sf"
	SF_CFG_GUEST_DIR="${SF_SHMDIR}/config-for-guest" # Mounted to /config/guest
	SF_GUEST_SELFDIR="${SF_SHMDIR}/self-for-guest"    # Mounted to /config/self
	SF_ENCFS_SEC_DIR="${SF_SHMDIR}/encfs-sec"
}


# shellcheck disable=SC2317 # Not reachable
cb_sighup()
{
	sem_release
	logout
	exit 200
}

# shellcheck disable=SC2317 # Not reachable
cb_sigterm()
{
	sem_release
	logout
	exit 201
}

init_vars()
{
	local db_dir
	init_defaults
	init_emu

	[[ -f "/sf/run/logs/segfault.log" ]] && IS_LOGGING=1

	NOW="$(date +%s)"
	[[ -z $YOUR_IP ]] && {
		YOUR_IP="${SSH_CONNECTION%%[[:space:]]*}"
		YOUR_IP="${YOUR_IP//[^0-9.:]/}"
		[[ -z $YOUR_IP ]] && ERREXIT 255 "SSH_CONNECTION= is is not set. segfaultsh not started via sshd?"
	}
	YOUR_IP_DISPLAY="$YOUR_IP"
	[[ -n $SF_HIDEIP ]] && YOUR_IP_DISPLAY="${YOUR_IP%%.*}.0.0.333"

	# Do not store IP addresses. Hash it with a secret (SEED) instead.
	local str
	str="$(echo -n "IP-${YOUR_IP}-${SF_SEED}" | sha512sum)"
	YOUR_IP_HASH="${str:0:16}"
	[[ -z $YOUR_IP_HASH ]] && ERREXIT 2 "YOUR_IP_HASH= not set"

	[[ -z $SF_FQDN ]] && SF_FQDN="this"
	db_dir="${SF_CONFIG_DIR}/db"
	SF_USER_DB_DIR="${db_dir}/user/lg-${LID}"
	SF_BLACKLIST_DIR="${db_dir}/banned"
	SF_TOKEN_DIR="${db_dir}/token"
	HNLID_DIR="${db_dir}/hn"

	SF_RUN_DIR="/sf/run/"
	LG_PID_DIR="${SF_RUN_DIR}/pids"
	LG_PID_FILE="${LG_PID_DIR}/pid-${LID}.$$"
	TS_LOGOUT_FILE="${SF_USER_DB_DIR}/ts_logout"
	TS_LOGIN_FILE="${SF_USER_DB_DIR}/ts_login"
	TS_RUN_FILE="${SF_USER_DB_DIR}/ts_run"
	IS_LOGGED_IN_FILE="${SF_USER_DB_DIR}/is_logged_in"

	# Set the number of CPU's a guest can use up to a max of 4.
	# Min is 1 or NPROC / 4 to a max of 4.
	[[ -z $SF_CPUS ]] && {
		SF_CPUS=$((NPROC / 4))
		if [[ $SF_CPUS -le 1 ]]; then
			SF_CPUS=1
			[[ $NPROC -ge 2 ]] && SF_CPUS=2
		elif [[ $SF_CPUS -gt 4 ]]; then
			SF_CPUS=4
		fi
	}

	# Check if we are still in sshd's Network Namespace
	IS_SSHD_NS_NET=1
	[[ ${SF_NS_NET:?} != "$(readlink /proc/self/ns/net)" ]] && unset IS_SSHD_NS_NET # Already inside LG's Network Namespace

	trap cb_sighup SIGHUP
	trap cb_sigterm SIGTERM
	trap cb_sighup SIGPIPE
}

mk_portforward()
{
	local ipport

	ipport=$(echo -e "DEL portd:response-${LID}\"\n\
RPUSH portd:blcmd \"getport ${LID}\"\n\
BLPOP portd:response-${LID} 5" | redr) || return
	# DEBUGF "ipport='$ipport'"
	ipport="${ipport##*$'\n'}"
	[[ ! "${ipport##*:}" -gt 0 ]] && { DEBUGF "Failed to get Reverse Port Forward (ipport='$ipport')"; return; }

	# The PortD add's a /sf/run/self/reverse_forward.
	DEBUGF "Reverse Port Forward: $ipport"
}

# Called when a new server is created.
print_disclaimer()
{
	echo 1>&2 -e "\
${CR}######################################################################
#### ${CY}DISCLAIMER: TO BE USED FOR CREATIVE AND GOOD PURPOSES ONLY.. ${CR}####
#### ${CY}TO TINKER AND TO EXPLORE.     >>>USE AT YOUR OWN RISK<<<     ${CR}####
######################################################################${CN}"
}

# Return TRUE if 'y' is pressed.
prompt_wait_yN()
{
	local p
	local sec
	local IFS
	sec=$1
	p="$2"

	echo -en "$p (y/N) "
	IFS=$'\n'
	read -r -n1 -t"${sec}" yn || { echo -e "${CF}N${CN}"; return 255; } # Timeout. Print "N\n"
	[[ -z $yn ]] && return 255                       # Enter pressed. \n already displayed (echo'ed)
	echo "" # Print \n
	[[ "${yn^^}" != "Y" ]] && return 255

	return 0
}

# Output GOODBYE message with infos how to connect back to this shell
print_goodbye()
{
	local str
	local IFS
	[[ -z $IS_LOGIN ]] && return
	[[ -n $SF_HUSHLOGIN ]] && return

	# Restricted shell (-r) wont let us redirect stderr - use a bash-exec trick
	# Note: pgrep is executed in user's context. Treat the output with care and do not trust it.
	n=$(bash -c "exec docker exec --user 0:0 \"lg-${LID}\" pgrep -c . 2>/dev/null" | head -n1)
	[[ -z "$n" ]] && n=0
	[[ ${#n} -gt 5 ]] && n=0
	[[ ! $n -eq $n ]] && n=0
	n=$((n-2))

	if [[ "$n" -gt 0 ]]; then
		# Display the running processes
		str="process is"
		[[ "$n" -gt 1 ]] && str="processes are"
		echo -e "${CY}WARNING: ${CR}${n}${CY} ${str} still running:${CN}"
		exec_errnull docker exec --user 0:0 "lg-${LID}" pgrep . -al | tail -n+3 | while read -r x; do p="${x%% *}        "; n="${x#* }"; echo -e "${CDY}--> ${CDR}${p:0:8}${CDG}${n:0:68}${CN}"; done
		echo -e "\
-------> The encrypted filesystem in /sec will remain accessible until
-------> the last shell exits or all background processes terminate.
-------> Log back in and type ${CC}halt${CN} instead to stop this server.
-------> This will also make /sec unavailabe until your next log in."
	fi
	echo -en "\r"
	[[ -z $SF_IS_PAYING ]] && {
		echo -e "\
${CDY}@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@   ${CDG}** GET MORE MEMORY, SPEED, STORAGE AND NO RESTRICTIONS **${CDY}   @@@
@@@             ${CDR}${CUL}https://www.thc.org/segfault/free${CN}${CDY}                 @@@
@@@             ${CB}${CUL}https://www.thc.org/segfault/upgrade${CN}${CDY}              @@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@${CN}"

	}

	echo -e "\
RTFM             : ${CB}${CUL}https://www.thc.org/segfault/faq${CN}
GOODBYE          : ${CW}Join us on Telegram - https://t.me/thcorg${CN}"
	[[ -z $SF_IS_NEW_SERVER ]] && return

	prompt_wait_yN 10 "Would you like to see your ${CDY}SECRET${CN} to log back in to ${CDY}${SF_HOSTNAME:-UNKNOWN}${CN}?" || return

	echo -e "\
SECRET           : ${CDY}${SF_SEC}${CN}
Access with      : ${CDC}ssh secret@${SF_FQDN:-UNKNOWN}${CN}
Access with      : ${CDC}ssh -o \"SetEnv SECRET=${SF_SEC:-UNKNOWN}\" ${SF_USER}@${SF_FQDN:-UNKNOWN}${CN}"
}

print_to_many_servers()
{
	echo >&2 -e "\
[${CR}ERROR${CN}]
--> ${CDY}You ($YOUR_IP) already have ${SF_LIMIT_SERVER_BY_IP} servers running.${CN}
--> Log in to your already running servers before creating any more new servers.
--> Read ${CB}${CUL}https://www.thc.org/segfault/faq/#reconnect${CN}
--> Read ${CB}${CUL}https://www.thc.org/segfault/free${CN}
--> Contact us on Telegram: ${CW}https://t.me/thcorg${CN}"
}

show_last_server()
{
	local n=$1
	echo >&2 -e "\
[${CDY}WARNING${CN}]
--> You (${CDY}$YOUR_IP${CN}) now have $n servers running.
--> ${CRY}You can not create any more servers after this one!${CN}
--> Use your ${CDY}SECRET${CN} to log in to your previously
--> created servers. If you forgot the ${CDY}SECRET${CN} then you need to wait for
--> the servers to time out and shut down automatically. Best to write down
--> the ${CDY}SECRET${CN} for THIS SERVER and follow these instructions:
--> ${CB}${CUL}https://www.thc.org/segfault/faq/#reconnect${CN}"

	prompt_wait_yN 30 "Would you like to see your ${CDY}SECRET${CN} now?" && {
		echo >&2 -e "\
--> SECRET: ${CDY}${SF_SEC:-BAD}${CN}
--> Contact us on Telegram: ${CW}https://t.me/thcorg${CN}"
	}
}

echo_pty() { :;}

sshd_to_ns()
{
	# local upid
	local str

	[[ -z $IS_SSHD_NS_NET ]] && return  # Already in LG's network namespace?

	# Load PID of container's init process (uid=1000)
	[[ -z $LG_PID ]] && {
		LG_PID=$(<"/sf/run/pids/lg-${LID}.pid")
		[[ -z $LG_PID ]] && ERREXIT 222 "Init PID not found."
	}
	ln -sf "/proc/${LG_PID}/ns/net" "/dev/shm/ns-net-${PPID}"
	DEBUGF "Moving SSHD(=$PPID) to net-NS(=$LG_PID)"
	kill -USR1 "$PPID" || ERREXIT 221 "Oops. Could not signal SSHD ($PPID)."
}

spawn_shell_exit()
{
	# $@ is either ("-c", "<command>") or empty
	DEBUGF "ARG(${#})=$*"

	# Move SSHD to guest's network namespace (for -L/-R to work)
	sshd_to_ns

	sem_release

	# Update current IP:
	tofile "${YOUR_IP_DISPLAY:?}" "/config/self-for-guest/lg-${LID}/ip"
	tofile "${YOUR_IP:?}" "/sf/run/ips/lg-${LID}.ip"
	[[ -n $YOUR_GEOIP ]] && tofile "${YOUR_GEOIP}" "/config/self-for-guest/lg-${LID}/geoip"
	# Request a reverse Port Forward
	[[ ! -f "/config/self-for-guest/lg-${LID}/reverse_ip" ]] && mk_portforward "${LID}"

	# Warn user if this is the last server by IP (after semaphore has been released)
	[[ -n $IS_SHOW_LAST_SERVER ]] && show_last_server "$IS_SHOW_LAST_SERVER"

	# export SF_LOG="/config/host/log/sigproxy-${LID}-${SF_HOSTNAME}.log"
	docker-exec-sigproxy exec --detach-keys='ctrl-^,z' --workdir=/sec/root --env SF_IS_LOGINSHELL=1 --user 0:0 "${DOCKER_EXEC_ARGS[@]}" "lg-${LID}" nice -n"${SF_USER_NICE_SCORE:?}" zsh "${PARAM[@]}"
	ret="$?" # save return value and exit this script later with same return value.
	DEBUGF "Exited with $ret"
	logout
	print_goodbye

	exit "$ret"
}

# Generate a mnemonic hostname from LID (e.g. ButterflyCat)
mk_hostname()
{
	NUM=$(echo "$LID" | md5sum)
	NUM=${NUM%% *}
	NUM=$((16#${NUM:0:15}))
	# Oops. bash max integer is (2^63)-1, so limit to 15 hex.
	# NUM=$(echo "ibase=16; $(echo "$LID" | md5sum | cut -f1 -d" " | tr 'a-z' A-Z)" | bc)
	readarray -t english <"${SF_HOST_FS_ROOT}/etc/english.txt"
	SF_HOSTNAME="UnknownUnknown"
	[[ "${#english[@]}" -lt 2048 ]] && ERREXIT 2 "english.txt bad"
	m=$((NUM % 2048))
	n=$(( (NUM / 2048) % 2048))
	SF_NUM="$((m * 2048 + n))"

	SF_HOSTNAME="${english[$m]}"
	SF_HOSTNAME+="${english[$n]}"
	unset NUM
	unset english
}

setup_fs_limit()
{
	# Return if 0 or not set
	[[ ! "${SF_USER_ROOT_FS_SIZE_NUM}" -gt 0 ]] && return 0 # true

	# Backing FS must be of type XFS
	[[ "${SF_BACKING_FS}" != "xfs" ]] && ERREXIT 1 "Backing FS is not XFS but SF_USER_ROOT_FS_SIZE is set"

	DOCKER_ARGS+=("--storage-opt")
	DOCKER_ARGS+=("size=${SF_USER_ROOT_FS_SIZE:?}")
}

# 1. Set INODE limit per container. Docker does not support this via any
# --storage-opt. Instead we start the container and add ourself to the
# xfs quota group that docker set up. Yeahaaa..
# 2. Move encfsd into lg's cgroup.
setup_encfsd()
{
	local dir
	local ilimit

	ilimit="$SF_USER_ROOT_FS_INODE"
	[[ -z "${SF_USER_ROOT_FS_SIZE_NUM}" ]] && ilimit=0

	dir=$(docker inspect "lg-${LID}" --format '{{.GraphDriver.Data.UpperDir }}') || return 255
	dir=${dir#*overlay2/}

	res=$(echo -e "RPUSH encfs \"$$ ${LID} X ${CID} ${ilimit:-0} ${dir}\"\n\
BLPOP \"encfs-$$-${LID}-X\" 10" | red) || return 255

	return 0
}

load_limits()
{
	# Set the default values.
	# No default for ROOT_FS limit. Should be set in sf.conf or if not set
	# then root is mounted read-only
	#SF_USER_ROOT_FS_SIZE=2GB
	SF_USER_ROOT_FS_INODE=65536
	SF_USER_MEMORY_LIMIT=256MB
	SF_USER_PIDS_LIMIT=128
	SF_USER_CPU_SHARE=8
	SF_USER_OOM_SCORE=500
	SF_USER_NICE_SCORE=10
	SF_LIMIT_SERVER_BY_IP=8
	SF_USER_BLKIO_WEIGHT=100
	SF_ULIMIT_NOFILE="1024:8192"
	SF_USER_SYN_BURST=8196
	SF_USER_SYN_LIMIT=1
	SF_USER_DL_BURST=8gb
	SF_USER_UL_BURST=8gb

	# No new shells until load goes below STRAIN*NPROC.
	# Should be larger than ContainerGuard's strain when CG starts killing
	SF_MAX_STRAIN=100

	# Test blkio_weight:
	# dd bs=1M count=10024 if=/dev/zero of=/dump.dat oflag=direct status=progress

	# Source system wide limits
	[[ -f "${SF_ETCSF_DIR}/sf.conf" ]] && eval "$(<"${SF_ETCSF_DIR}/sf.conf")"

	# Then source token specific limits (and write TOKEN information)
	if [[ -z $SF_TOKEN ]]; then
		[[ -f "${SF_USER_DB_DIR}/token" ]] && {
			SF_TOKEN="$(<"${SF_USER_DB_DIR}/token")"
			# Delete user token if token no longer exists
			[[ ! -f "${SF_TOKEN_DIR}/token-${SF_TOKEN,,}.conf" ]] && {
				rm -f "${SF_USER_DB_DIR}/token"
				unset SF_TOKEN
			}
		}
	else
		# HERE: SF_TOKEN is user supplied.
		if [[ ! -f "${SF_TOKEN_DIR}/token-${SF_TOKEN,,}.conf" ]]; then
			# HERE: Token is INVALID
			unset SF_TOKEN
		else
			# Update TOKEN
			tofile "${SF_TOKEN}" "${SF_USER_DB_DIR}/token"
		fi
	fi
	[[ -n $SF_TOKEN ]] && [[ -f "${SF_TOKEN_DIR}/token-${SF_TOKEN,,}.conf" ]] && eval "$(<"${SF_TOKEN_DIR}/token-${SF_TOKEN,,}.conf")"

	# Then source user specific limits
	[[ -f "${SF_USER_DB_DIR}/limits.conf" ]] && eval "$(<"${SF_USER_DB_DIR}/limits.conf")"

	# Then source IP specific limits
	[[ -f "${SF_ETCSF_DIR}/sf-${YOUR_IP}.conf" ]] && eval "$(<"${SF_ETCSF_DIR}/sf-${YOUR_IP}.conf")"

	# Set swap limit if not set in sf.conf
	[[ -z $SF_USER_MEMORY_AND_SWAP_LIMIT ]] && SF_USER_MEMORY_AND_SWAP_LIMIT="$SF_USER_MEMORY_LIMIT"

	# Use MAX-MEMORY if no other limit is set.
	[[ -z $SF_SHM_SIZE ]] && SF_SHM_SIZE=$SF_USER_MEMORY_LIMIT

	[[ -n $SF_USER_ROOT_FS_SIZE ]] && {
		SF_USER_ROOT_FS_SIZE_NUM="${SF_USER_ROOT_FS_SIZE//[^[:digit:]]/}"
		[[ -z $SF_USER_ROOT_FS_SIZE_NUM ]] && ERREXIT 255 "no digit in SF_USER_ROOT_FS_SIZE="
	}

	SF_MAX_LOAD="$(( ${NPROC:-1} * SF_MAX_STRAIN ))"

	DOCKER_ARGS+=("--memory=${SF_USER_MEMORY_LIMIT}")
	# Setting memory-swap and memory to same value will disable swapping
	DOCKER_ARGS+=("--memory-swap=${SF_USER_MEMORY_AND_SWAP_LIMIT}")
	DOCKER_ARGS+=("--pids-limit=${SF_USER_PIDS_LIMIT}")
	DOCKER_ARGS+=("--cpu-shares=${SF_USER_CPU_SHARE}")
	DOCKER_ARGS+=("--oom-score-adj=${SF_USER_OOM_SCORE}")
	DOCKER_ARGS+=("--blkio-weight=${SF_USER_BLKIO_WEIGHT}")

	if [[ -z $SF_USER_ROOT_FS_SIZE ]]; then
		DOCKER_ARGS+=("--read-only")
	else
		# HERE: Root-FS / is _writeable_ by user.
		[[ ${SF_USER_ROOT_FS_SIZE_NUM} -gt 0 ]] && {
			# HERE: Root-Fs is LIMITED in size
			# These files must be mounted read-only as these are special files
			# for docker and ingored by --opt storage-size= limitations.
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/etc/hosts:/etc/hosts:ro")
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/db/user/lg-${LID}/hostname:/etc/hostname:ro")
			DOCKER_ARGS+=("-v${SF_BASEDIR}/config/etc/resolv.conf:/etc/resolv.conf:ro")
		}
	fi

	[[ -n $SF_SHM_SIZE ]] && DOCKER_ARGS+=("--shm-size=$SF_SHM_SIZE")

	[[ -n $SF_SYSBOX ]] && SYSBOX_ARGS+=("--runtime=sysbox-runc")

	setup_fs_limit || ERREXIT 202 "Can't configure XFS limit"
}

# Publish user limits to self/limits
write_guest_limits()
{
	local is_token
	local is_ro

	is_token="no"
	[[ -n $SF_TOKEN ]] && is_token="yes"

	[[ -z $SF_USER_ROOT_FS_SIZE ]] && is_ro="read-only"
	tofile "\
TOKEN_USED=${is_token}
CPUS=${SF_CPUS}
ROOT_SIZE=${is_ro:-$SF_USER_ROOT_FS_SIZE}
ROOT_FILES=${is_ro:-$SF_USER_ROOT_FS_INODE}
SEC_SIZE=${SF_USER_FS_SIZE:-unlimited}
SEC_FILES=${SF_USER_FS_INODE:-unlimited}
SHM_SIZE=${SF_SHM_SIZE}
PIDS=${SF_USER_PIDS_LIMIT}
MEMORY=${SF_USER_MEMORY_LIMIT}
NOFILE=${SF_ULIMIT_NOFILE}
TX=${SF_MAXOUT}
RX=${SF_MAXIN:-unlimited}
SYN_BURST=${SF_USER_SYN_BURST}
SYN_RATE=${SF_USER_SYN_LIMIT}/sec
SERVERS=${SF_LIMIT_SERVER_BY_IP}
GREETINGS='${SF_SYSCOP_MSG}'" "/config/self-for-guest/lg-${LID}/limits"
}

check_banned()
{
	local blfn

	[[ -e "${SF_BLACKLIST_DIR}/ip-${YOUR_IP}" ]] && blfn="${SF_BLACKLIST_DIR}/ip-${YOUR_IP}"
	[[ -z $blfn ]] && [[ -e "${SF_BLACKLIST_DIR}/net-${YOUR_IP%\.*}" ]] && blfn="${SF_BLACKLIST_DIR}/net-${YOUR_IP%\.*}"
	[[ -z $blfn ]] && return

	LOG_W "BANNED (${YOUR_IP}) (${CDY}$(<"$blfn")${CN})"
	sleep 10
	echo -e "${CR}@@@@@ YOUR IP (${YOUR_IP}) HAS BEEN BANNED. Contact us if you feel that this is wrong. @@@@@${CN}"
	if [[ -s "$blfn" ]]; then
		cat "$blfn"
	fi
	sleep 120
	exit 255
}

# wait_for_conn_limit <ID> <ts_window>
# Allow a max of 5 new connections within <ts_window>.
# Give up after 120 seconds.
#   ID - is either "all" for system wide limit or YOUR_IP_HASH for per IP limit
wait_for_conn_limit()
{
	local ts_window
	local id
	local n
	local fn

	id="$1"
	ts_window="$2"
	fn="/dev/shm/conn-${id}.conf"
	# Do not allow more than 5 new connections in 30 seconds.
	ARR=(0 0 0 0 0)
	[[ -f "${fn}" ]] && {
		NOW="$(date +%s)"
		local ts_good
		local c
		c=0
		while :; do
			eval "$(grep ^ARR "${fn}")"

			ts_good=$((NOW - ts_window))
			[[ ${ARR[0]} -lt $ts_good ]] && break

			[[ $c -gt 60 ]] && echo -e >&2 "giving up. Try again later." && exit 255
			[[ $c -eq 0 ]] && echo -e >&2 "[${CY}SF${CN}] Waiting for resources..."
			echo -n "."
			sleep 2
			((c++))
			((NOW+=2))
		done
		[[ $c -gt 0 ]] && echo -e >&2 "[${CG}OK${CN}]"
	}
	tofile "ARR=(${ARR[*]:1:4} $NOW)" "${fn}"
}

wait_for_load()
{
	local load
	local max="$1"
	local n

	while :; do
		read -r -a load </proc/loadavg
		[[ ${load[0]%%.*} -lt "$max" ]] && break
		echo -e >&2 "[${CY}SF${CN}] Waiting for load to go down..."
		sleep 5
		((n++))
		[[ $n -ge 20 ]] && ERREXIT 255 "giving up."
	done
}

wait_for_resources()
{
	# 5 Connections within 60 seconds from the same IP.
	wait_for_conn_limit "${YOUR_IP_HASH}" "60" 
	# 5 Connections within 10 seconds all in all
	wait_for_conn_limit "all" "10"

	wait_for_load "${SF_MAX_LOAD}"
}

print_relay_notice()
{
	sleep 5
    echo >&2 -e "\
[${CR}ERROR${CN}]
--> You (${CDY}$YOUR_IP${CN}) are trying to connect from a Relay.
--> Log in from Relays is available for ${CG}VALUED${CN} users only.
--> To log in from Relays please ask us for an ACCESS TOKEN.
--> Read ${CB}${CUL}https://www.thc.org/segfault/free${CN}
--> Contact us on Telegram: ${CW}https://t.me/thcorg${CN}"
	sleep 5
}

# Check if login from Tor is ENABLED.
# TODO: Make this work with the IP hashes
check_relay_status()
{
	local is_relay
	local fn

	# FIXME: If user is allowed to log in via TOR then we should use
	# the TOKEN to limit his number of servers.
	[[ -n $SF_ALLOW_SRC_TOR ]] && return
	if [[ "${YOUR_IP}" == "${SF_TOR_IP}" ]]; then
		is_relay=1
	else
		[[ -f "/sf/share/tor-exit-nodes.txt" ]] && fn+=("/sf/share/tor-exit-nodes.txt")
		[[ -f "/sf/share/relay-exit-nodes-mullvad.txt" ]] && fn+=("/sf/share/relay-exit-nodes-mullvad.txt")
		[[ -f "/config/host/etc/relay-exit-nodes-global.txt" ]] && fn+=("/config/host/etc/relay-exit-nodes-global.txt")
		
		exec_devnull grep -q -Fx "^${YOUR_IP}" "${fn[@]}" && is_relay=1
	fi

	[[ -z $is_relay ]] && return

	print_relay_notice
	LOG_W "RELAY DENIED"
	ERREXIT 255
}

print_timer()
{
	local c
	c=$1

	[[ -z $c ]] && c=10

	while [[ $c -gt 0 ]]; do
		echo -ne >&2 "Continuing in $c sec...   "$'\r'
		sleep 1
		((c--))
	done
}

usermsg()
{
	[[ ! -f "${SF_USER_DB_DIR}/syscop-msg.txt" ]] && return
	[[ -n $SF_HUSHLOGIN ]] && return

	### Show during IS_LOGIN _and_ COMMAND execution but use STDERR
	echo -e >&2 "\
${CDY}@@@@@@@@@@@@@@@@@@ SysCops Message @@@@@@@@@@@@@@@@@@@@@@@${CN}
${CR}$(<"${SF_USER_DB_DIR}/syscop-msg.txt")
${CW}[[[ Contact us on TG and let's talk about our feelings ]]]
${CDY}@@@@@@@@@@@@@@@@@@ SysCops Message @@@@@@@@@@@@@@@@@@@@@@@${CN}"
	echo -en >&2 "\e[?25l"  # Hide cursor
	if [[ -t 0 ]]; then
		print_timer 30
		echo -en >&2 "Press any key to continue."
		read -r -n1
	else
		echo -en >&2 "\e[25lContinuing in 30 seconds..."
		sleep 30
	fi
	echo -en >&2 "\e[?25h"$'\r'

	rm -f "${SF_USER_DB_DIR}/syscop-msg.txt"
}

# Check if max servers per IP are in use.
check_limit_server_by_ip()
{
	local fn
	local arr_new
	local str

	[[ -z $SF_LIMIT_SERVER_BY_IP ]] && return
	[[ -n $SF_IS_PAYING ]] && return

	[[ -n $IS_TRY_EXISTING ]] && {
		# SECRET= was supplied.
		# If it's running then allow to connect to existing (it's not a new server).
		exec_devnull docker container inspect "lg-${LID}" -f '{{.State.Status}}' && return
	}

	fn="/dev/shm/ip-${YOUR_IP_HASH}.conf"

	[[ -f "$fn" ]] && {
		eval "$(grep ^ARR "$fn")"

		local n
		local lid
		n=0
		for lid in "${ARR[@]}"; do
			[[ -z $lid ]] && break
			### Check if any of the shells are still alive
			str="$(exec_errnull docker container inspect "lg-${lid}" -f '{{.State.Status}}')" || continue

			# Container can be in "Created" state (reason is unknown)
			[[ "$str" != "running" ]] && {
				# FIXME: A rare race condition (which in worst case terminates the shell)
				# when a container was recently created and a user creates another server
				# before the old container entered RUNNING state. Disregard this scenario.
				exec_devnull docker stop "lg-${lid}"
				continue
			}
			((n++))
			arr_new+=("$lid")
		done

		## Eyy, good idea to check if they are idle?
		[[ "$n" -ge "${SF_LIMIT_SERVER_BY_IP}" ]] && {
			print_to_many_servers
			LOG_W "TO MANY SERVERS FOR ${YOUR_IP}"
			ERREXIT 254
		}

		[[ "$((n+1))" -ge "${SF_LIMIT_SERVER_BY_IP}" ]] && [[ -z $HUSHLOGIN ]] && [[ -n $IS_LOGIN ]] && IS_SHOW_LAST_SERVER="$((n+1))"

		[[ "$n" -ge 1 ]] && {
			# The 3rd and more servers from same IP get less CPU share
			SF_USER_CPU_SHARE=2
			SF_USER_OOM_SCORE=1000
			SF_USER_NICE_SCORE=19
			SF_USER_BLKIO_WEIGHT=10
			# DEBUGF "${n}. server from ${YOUR_IP}. CPU_SHARE=${SF_USER_CPU_SHARE}, OOM=${SF_USER_OOM_SCORE}."
		}
	}

	tofile "ARR=(${arr_new[*]} $LID)" "$fn"
}

# We must not request the guest's IP over the network (leakage). The best we can do is
# lookup his IP in a local database.
mk_geoip()
{
	local ip
	ip="${1}"
	[[ ! -f /sf/share/GeoLite2-City.mmdb ]] && return
	[[ -z ${ip} ]] && return

	local city
	local country
	res=$(mmdbinspect --db /sf/share/GeoLite2-City.mmdb "${ip}")
	[[ -z $SF_HIDEIP ]] && city=$(echo "$res" | jq -r '.[0].Records[0].Record.city.names.en | select(. != null)')
	country=$(echo "$res" | jq -r '.[0].Records[0].Record.country.names.en | select(. != null)')

	unset YOUR_GEOIP
	if [[ -n $city ]] && [[ -n $country ]]; then
		YOUR_GEOIP="${city}/${country}"
	elif [[ -n $city ]] || [[ -n $country ]]; then
		YOUR_GEOIP="${city}${country}" # Either one but not both
	fi
}

sysmsg()
{
	local fn
	fn="$1"

	[[ ! -f "$1" ]] && return
	eval "$(<"$fn")"
}

# Instruct docker to assign TTY if input is a TTY (ssh -t <user@host> <command>)
DOCKER_EXEC_ARGS=("-i")
if [[ -t 0 ]]; then
	# Disable SIGINT and SIGSTP. Use 'trap' first as 'stty' can be interrupted itself!
	trap "" SIGINT
	stty -isig
	DOCKER_EXEC_ARGS=("-it")
fi

if [[ ${#} -eq 2 ]]; then
	# HERE: command via "-c" "cmd"
	PARAM=("-c" "${2}");
elif [[ ${#} -eq 0 ]]; then
	# - Set docker arguments to login-shell or profile wont get read.
	PARAM=("-il")
	# For -c "cmd" we silence output but for login shells we show
	IS_LOGIN=1
else
	ERREXIT 255 "BAD PARAMS: '${*}'"
fi

### ----BEGIN SANTIZE----
[[ -n $HUSHLOGIN ]] && { SF_HUSHLOGIN=1; DOCKER_EXEC_ARGS+=("--env" "SF_HUSHLOGIN=1"); }
[[ -n $HIDEIP ]] && SF_HIDEIP=1
[[ -n $SF_DEBUG ]] && SF_DEBUG=1

[[ -n $SF_IS_ASKSECSH ]] && {
	# login to secret@ to prompt for SECRET
    unset err
    while :; do
        echo -e -n "\U1F480 ${CDY}SECRET${CN}: ${CDC}"
        read -r -n128 -t30 SECRET || err=1
        echo -en "${CN}"
        [[ -n $err ]] && exit 255
        SECRET="${SECRET//[^0-9a-zA-Z-]}"
		SECRET="${SECRET##*-}"  # Remove host part 'lsd-ABCD...'
        [[ ${#SECRET} -eq 24 ]] && break
        [[ "$SECRET" == exit ]] && exit 0
        [[ "$SECRET" == new ]] && { unset SECRET; break; }
        echo -e "${CDR}ERROR${CN}: Must be 24 characters. Type ${CDC}exit${CN} to exit or ${CDC}new${CN} to generate."
    done
}
# SECRET and SF_DEBUG are user supplied.
# Connect to existing session

if [[ -n $SECRET ]]; then
	SECRET="${SECRET//[^a-zA-Z0-9-]}"
	SECRET="${SECRET##*-}"  # Remove host part 'lsd-ABCD...'
	[[ ${#SECRET} -eq 24 ]] && {
		IS_TRY_EXISTING=1
		SF_SEC="${SECRET}"
	}
fi
[[ -z $SF_SEC ]] && SF_SEC="$(head -c 1024 /dev/urandom | tr -dc '[:alpha:]' | head -c 24)"

[[ -n $SF_IS_WEBSHELL ]] && {
	# Correct YOUR_IP
	REMOTE_ADDR="${REMOTE_ADDR//[^0-9.:]}"
	[[ -z $REMOTE_ADDR || ${#REMOTE_ADDR} -gt 32 ]] && ERREXIT "Bad REMOTE_ADDR: len=${#REMOTE_ADDR}"
	YOUR_IP="${REMOTE_ADDR}"
}

[[ -n $PRJ ]] && {
	SF_PRJ="${PRJ//[^a-zA-Z0-9._]}"
	SF_PRJ="${SF_PRJ:0:32}"
}

[[ -n $TOKEN ]] && {
	SF_TOKEN="${TOKEN//[^a-zA-Z0-9@]}"
	# TOKEN=User@foobarBLah.helloAbc => foobarBLahhelloAbc
	SF_TOKEN="${TOKEN##*@}"
	SF_TOKEN="${SF_TOKEN:0:32}"
}
# Unset user supplied env variables
unset SECRET HUSHLOGIN HIDEIP PRJ TOKEN
### ----END SANITIZE----

# Only output progress if this is a login shell _and_ not HUSHLOGIN
[[ -n $IS_LOGIN ]] && [[ -z $SF_HUSHLOGIN ]] && echo_pty() { echo "$@"; }

# Note: sha512sum outputs hex. The first character is always [0..9a..f].
# The base64 encoding means the LID will always start with N..Z.
LID=$(echo -n "LID ${SF_SEC}" | sha512sum | base64 -w0)
LID="${LID//[^[:alpha:]]}"
LID="${LID:0:10}"
export LID

[[ -z $SF_SEED ]] && ERREXIT 244 "SF_SEED= is not set."

# Show system messages
sysmsg "/sf/bin/loginmsg-all.sh"

# Call init_vars() after LID is set
init_vars
# Load CPU/PID/OOM limits (systemwide or user specific)
load_limits
# Check if IP is banned
check_banned

mk_hostname
HNLID_FILE="${HNLID_DIR}/hn2lid-${SF_HOSTNAME}"
LG_SEM="sema:lg-$(( (SF_NUM + SF_RAND_OFS) % SF_HM_SIZE_LG ))"

# Keep guest waiting until there are sufficient resources
wait_for_resources

# Check if connects originates from a Relay
check_relay_status

### Check if the limit has been reached for this source IP
check_limit_server_by_ip

# Check if share got unmounted (e.g. EncFS died)
[[ ! -f "${SF_SEC_DIR}/.IS-ENCRYPTED" ]] && ERREXIT 243 "System not ready yet (wrong EncFS password. Please inform the admin to set correct SF_SEED)"

mk_geoip "${YOUR_IP}"

# Execute under "root" (uid=1001) context:
[[ ! -d "${HNLID_DIR}" ]] && { mkdir -p "${HNLID_DIR}" || ERREXIT; }

# Output user messages and wait for enter....
usermsg

if [[ -d "${SF_USER_DB_DIR}" ]]; then
	S="Your Server       : ${CDY}${SF_HOSTNAME:0:34}${CN}....................................................."
	echo_pty -en "${S:0:65}"
	touch "${HNLID_FILE}"
else
	print_disclaimer
	sysmsg "/sf/bin/loginmsg-new.sh"
	# ######################################################################
	# 70 long
	# Got 54 space
	# Creating Server => 16 chars
	# Color escape codes => 11 chars
	# Hostname max = 54 - 16
	# Final echo: 54 + 11
	S="Creating Server ${CDY}${SF_HOSTNAME:0:38}${CN}..................................................."
	echo_pty -en "${S:0:65}"

	# Check for collision where different SECRETs generates the same (and already existing) SF_NUM / SF_HOSTNAME:
	[[ -f "${HNLID_FILE}" ]] && [[ "$(<"${HNLID_FILE}")" != "${LID}" ]] && ERREXIT 69 "Collision. Wrong SECRET for $SF_HOSTNAME."
	SF_IS_NEW_SERVER=1
	DOCKER_EXEC_ARGS+=("--env" "SF_IS_NEW_SERVER=1")

	mkdir -p "${SF_USER_DB_DIR}" || ERREXIT
	touch "${SF_USER_DB_DIR}/created.txt" || ERREXIT
	tofile "$SF_NUM" "${SF_USER_DB_DIR}/num"
	tofile "$SF_HOSTNAME" "${SF_USER_DB_DIR}/hostname"
	[[ -d "${HNLID_DIR}" ]] || exec_devnull mkdir "${HNLID_DIR}"
	tofile "$LID" "${HNLID_FILE}" || ERREXIT 231 "tofile: Failed to create hnlid_file"
fi

DEBUGF "LID=${LID} SF_HOSTNAME=${SF_HOSTNAME}"
unset str
[[ -n $SF_LOG_IP ]] && str="[${CDY}${YOUR_IP}${CN}] "
str+="${CDG}${SF_HOSTNAME}"
[[ -n $SF_PRJ ]] && str+="/${CW}${SF_PRJ}"
LOG "${str}${CN} ${CDC}$*${CN}"

# Record which SSHD process is connect to guest LG.
tofile "SSHD_PID=$PPID
LID=$LID" "${LG_PID_FILE}"
touch "${TS_LOGIN_FILE}"
touch "${IS_LOGGED_IN_FILE}"

# Create EncFS password
encfspass=$(echo -n "EncFS-PASS-${SF_SEED}${SF_SEC}" | sha512sum | base64 -w0)
encfspass="${encfspass//[^[:alpha:]]}"
encfspass="${encfspass:0:24}"
[[ -z $encfspass ]] && ERREXIT 241 "Failed to create session password"

# Start & Wait for EncFS
res=$(echo -e "RPUSH encfs \"$$ ${LID} M ${encfspass}\"\n\
BLPOP \"encfs-$$-${LID}-M\" 20" | red) || ERREXIT 230 "Can't reach EncFSD"
echo_pty -n "...."

# Only one LG at a time (and wait any other connection to call 'docker exec' until it's fully running.
sem_wait

# Attach to container if already running
[[ -n $IS_TRY_EXISTING ]] && {
	# If state is not running then stop it.
	str="$(exec_errnull docker container inspect "lg-${LID}" -f '{{.State.Status}}')" && {
		[[ $str == "running" ]] && {
			echo_pty -e "..........[${CG}Ok${CN}]"
			DEBUGF "Attaching to existing container lg-${LID}..."
			LOG "Attaching to existing container"
			spawn_shell_exit "$@"
			# NOT REACHED
		}
		LOG "Container not in RUNNING state."
		# HERE: Container exists but not in RUNNING state.
		exec_devnull docker stop "lg-${LID}"
	}
	DEBUGF "FAILED to attached to lg-${LID}"
	# HERE: Container does not exists.
}

### Create ONION directory => From within encfsd (to set XFS quota)

# Starting GUEST shell
# Challenge: Keep user processes running that got spawned in the background
# even when first container terminates. Also do not terminate container
# when there are still shells using it ('docker exec').
# Solution: Spawn a container in the background and always use 'docker exec' to
# create a shell for the user.

# Use --init so that 2nd shell to same container keeps running even if 1st shell
# exits.
### Start the care taker...
selfdir="/config/self-for-guest/lg-${LID}"
xmkdir "${selfdir}"
[[ -n $SF_TOKEN ]] && tofile "${SF_TOKEN}" "/config/self-for-guest/lg-${LID}/token"
write_guest_limits

# Note: cgroup-parents: with cgroup-v1 the full path needs to be specified (e.g. sf.slice/sf-guest.slice) whereas with
# cgroup-v2 only sf-guest.slice need to be specified.
[[ -n $SF_IS_GOLD_PROMPT ]] && export SF_IS_GOLD_PROMPT
[[ -n $SF_PRJ ]] && export SF_PRJ
[[ -n $SF_DEBUG ]] && export SF_DEBUG
# exec_devnull docker run --runtime=sysbox-runc \
exec_devnull docker run \
	"${SYSBOX_ARGS[@]}" \
	--hostname "${SF_FQDN%%\.*}-${SF_HOSTNAME}" \
	"${DOCKER_ARGS[@]}" \
	--rm \
	--init \
	--cpus="${SF_CPUS}" \
	--cgroup-parent "${SF_CG_PARENT:?}" \
	--workdir=/ \
	--ulimit nofile="${SF_ULIMIT_NOFILE}" \
	--name "lg-${LID}" \
	--cap-drop=MKNOD \
	--net sf-guest \
	--add-host tor:"${SF_TOR_IP}"                           `# No effect when /etc/hosts is mounted read-only` \
	--add-host router:"${SF_NET_LG_ROUTER_IP}"              `# No effect when /etc/hosts is mounted read-only` \
	--add-host dns:"${SF_DNS}"                              `# No effect when /etc/hosts is mounted read-only` \
	--add-host rpc:"${SF_RPC_IP}"                           `# No effect when /etc/hosts is mounted read-only` \
	--add-host sf:"${SF_RPC_IP}"                            `# No effect when /etc/hosts is mounted read-only` \
	--dns "${SF_DNS:-BAD}" \
	--env SF_SEC="${SF_SEC}" \
	--env SF_TOR_IP="${SF_TOR_IP}" \
	--env SF_USER="${SF_USER}" \
	--env SF_FQDN="${SF_FQDN}" \
	--env SF_HOSTNAME="${SF_HOSTNAME}" \
	--env SF_LID="${LID}" \
	-e SF_PRJ \
	-e SF_IS_GOLD_PROMPT \
	-e SF_DEBUG \
	--log-driver "${SF_DOCKER_LOG}" \
	--tmpfs /tmp:exec                                       `# GoLang needs /tmp to be executeable` \
	--sysctl net.ipv6.conf.all.disable_ipv6=0               `# Allow IPv6 (used by WireGuard FOBs)` \
	--sysctl net.ipv4.tcp_tw_reuse=1                        `# Immediately reuse TIME_WAIT sockets` \
	--sysctl net.ipv4.tcp_fin_timeout=10 \
	-v "${SF_BASEDIR}/data/share/:/sf/share:ro" \
	-v "${SF_CFG_GUEST_DIR:?}/:/config/guest:ro" \
	-v "${SF_GUEST_SELFDIR:?}/lg-${LID}:/config/self:ro,slave" \
	-v "${SF_ENCFS_SEC_DIR}/lg-${LID}:/sec:slave" \
	-v "${SF_ENCFS_SEC_DIR}/everyone-root/everyone:/everyone:ro,slave" \
	-v "${SF_ENCFS_SEC_DIR}/everyone-root/everyone/${SF_HOSTNAME}:/everyone/${SF_HOSTNAME}:slave"  `# Mount myself RW over RO` \
	-v "${SF_ENCFS_SEC_DIR}/www-root/www/${SF_HOSTNAME,,}:/onion:slave" \
	"${LXCFS_ARGS[@]}" \
	--user 1000:1000 \
	-d \
	"sf-guest${SF_GUEST_CONTAINER_NAME_SUFFIX}" bash -c "exec -a '[init-${LID}-${SF_HOSTNAME}]' sleep infinity" || ERREXIT 251 "Failed-#1 to set up guest container..."
# Note: Run 'init/sleep' as user 1000:1000 so that sf-host's SSHD can move itself into this guest's
# network namespace. 

echo_pty -n ".."
DEBUGF "Container started..."
touch "${TS_RUN_FILE}"

# Wait for detached docker shell to enter 'running' state
n=0
while :; do
	str="$(exec_errnull docker container inspect "lg-${LID}" -f '{{.State.Status}}')" && {
		[[ "$str" == "running" ]] && break
	}
	DEBUGF "#${n} Waiting for sf-guest to be ready..."
	if [[ $n -gt 0 ]]; then sleep 5; else sleep 0.1; fi
	n=$((n+1))
	[[ $n -gt 2 ]] && STOPEXIT "${LID}" 253 "Could not create container..."
done
echo_pty -n ".."
# LOG "Container started & RUNNING..."

arr=($(docker inspect -f '{{.Id}} {{.State.Pid}} {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "lg-${LID}"))
CID=${arr[0]}
LG_PID=${arr[1]}
C_IP=${arr[2]}
[[ -z $C_IP ]] && ERREXIT 249 "Could not get container's IP address."
tofile "${LG_PID:?}" "/sf/run/pids/lg-${LID}.pid"

# Set up Root FS / inode limits and move encfsd to lg's cgroup
setup_encfsd || STOPEXIT "${LID}" 244 "Could not set FS quota."
echo_pty -n ".."

# Store LG information in Redis
res=$(red SET "ip:${C_IP}" "${LID} ${CID} ${LG_PID}") || STOPEXIT "$LID" 252 "Failed to set LID in Redis"

# Set FW rules for this container
exec_devnull docker exec sf-router /user-limit.sh "${YOUR_IP_HASH}" "${YOUR_IP}" "${C_IP}" "$SF_USER_SYN_LIMIT" "$SF_USER_SYN_BURST" "$SF_USER_DL_RATE" "$SF_USER_DL_BURST" "$SF_USER_UL_RATE" "$SF_USER_UL_BURST" || STOPEXIT "${LID}" 251 "Faild to set syn-limit...";

# Ready container
exec_devnull docker exec sf-master /ready-lg.sh "${LID}" "${C_IP}" "${LG_PID}" || STOPEXIT "${LID}" 246 "Failed-#3 to ready guest container..."

# Setup container (within container's namespace)
unset WGNAME_UP
[[ -s "${SF_USER_DB_DIR}/wg/name_up" ]] && WGNAME_UP="$(<"${SF_USER_DB_DIR}/wg/name_up")"
exec_devnull docker exec --user 0:0 --env SF_IS_NEW_SERVER="${SF_IS_NEW_SERVER}" --env WGNAME_UP="${WGNAME_UP}" "lg-${LID}" /sf/bin/sf-setup.sh || STOPEXIT "${LID}" 247 "Failed-#2 to set up guest container..."
touch "/config/self-for-guest/lg-${LID}/THIS-DIRECTORY-IS-IN-MEMORY-ONLY"
tofile "${C_IP:?}" "/config/self-for-guest/lg-${LID}/c_ip"

echo_pty -e "....[${CG}OK${CN}]"

# Spawn shell
spawn_shell_exit "$@"
# NOT REACHED

